"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pointDeltaRoundingDown = exports.pointDeltaRoundingUp = exports.point2PriceDecimal = exports.getTokenXYFromToken = exports.point2PriceUndecimal = exports.point2PoolPriceUndecimalSqrt = exports.priceUndecimal2Point = exports.priceDecimal2Point = exports.priceUndecimal2PriceDecimal = exports.priceDecimal2PriceUndecimal = void 0;
const types_1 = require("./types");
const bignumber_js_1 = require("bignumber.js");
const token_1 = require("./token");
/**
 * transform decimal price to undecimal price
 * @param tokenA tokenA info in format of [[`TokenInfoFormatted`]], only decimal field is needed
 * @param tokenB tokenB info in format of [[`TokenInfoFormatted`]], only decimal field is needed
 * @param priceDecimalAByB decimal-price how much tokenB (decimal amount) for 1 tokenA
 * @returns undecimal price
 */
const priceDecimal2PriceUndecimal = (tokenA, tokenB, priceDecimalAByB) => {
    // priceDecimalAByB * amountADecimal = amountBDecimal
    // priceDecimalAByB * (amountA / 10^decimalA) = amountB / 10^decimalB
    // priceDecimalAByB / 10^decimalA * 10^decimalB * amountA = amountB
    return new bignumber_js_1.BigNumber(priceDecimalAByB).times(Math.pow(10, tokenB.decimal)).div(Math.pow(10, tokenA.decimal));
};
exports.priceDecimal2PriceUndecimal = priceDecimal2PriceUndecimal;
const priceUndecimal2PriceDecimal = (tokenA, tokenB, priceUndecimalAByB) => {
    // priceUndecimalAByB * amountA = amountB
    // priceUndecimalAByB * amountADecimal * 10^decimalA = amountBDecimal * 10^decimalB
    // priceUndecimalAByB * 10^decimalA / 10^decimalB * amountA = amountB
    return Number(priceUndecimalAByB.times(Math.pow(10, tokenA.decimal)).div(Math.pow(10, tokenB.decimal)));
};
exports.priceUndecimal2PriceDecimal = priceUndecimal2PriceDecimal;
function _xyPriceDecimal2Point(tokenX, tokenY, priceDecimalXByY, roundingType) {
    const priceUndecimalXByY = (0, exports.priceDecimal2PriceUndecimal)(tokenX, tokenY, priceDecimalXByY);
    const point = Math.log(Number(priceUndecimalXByY)) / Math.log(1.0001);
    if (roundingType === types_1.PointRoundingType.POINT_ROUNDING_NEAREST) {
        return Math.round(point);
    }
    else if (roundingType === types_1.PointRoundingType.POINT_ROUNDING_UP) {
        return Math.ceil(point);
    }
    else {
        return Math.floor(point);
    }
}
function _xyPriceUndecimal2Point(priceUndecimalXByY, roundingType) {
    const point = Math.log(priceUndecimalXByY) / Math.log(1.0001);
    if (roundingType === types_1.PointRoundingType.POINT_ROUNDING_NEAREST) {
        return Math.round(point);
    }
    else if (roundingType === types_1.PointRoundingType.POINT_ROUNDING_UP) {
        return Math.ceil(point);
    }
    else {
        return Math.floor(point);
    }
}
const priceDecimal2Point = (tokenA, tokenB, priceDecimalAByB, roundingType) => {
    if ((0, token_1.getSwapTokenAddress)(tokenA).toLowerCase() < (0, token_1.getSwapTokenAddress)(tokenB).toLowerCase()) {
        let pointRoundingType = types_1.PointRoundingType.POINT_ROUNDING_NEAREST;
        if (roundingType === types_1.PriceRoundingType.PRICE_ROUNDING_DOWN) {
            pointRoundingType = types_1.PointRoundingType.POINT_ROUNDING_DOWN;
        }
        if (roundingType === types_1.PriceRoundingType.PRICE_ROUNDING_UP) {
            pointRoundingType = types_1.PointRoundingType.POINT_ROUNDING_UP;
        }
        return _xyPriceDecimal2Point(tokenA, tokenB, priceDecimalAByB, pointRoundingType);
    }
    else {
        let pointRoundingType = types_1.PointRoundingType.POINT_ROUNDING_NEAREST;
        if (roundingType === types_1.PriceRoundingType.PRICE_ROUNDING_DOWN) {
            pointRoundingType = types_1.PointRoundingType.POINT_ROUNDING_UP;
        }
        if (roundingType === types_1.PriceRoundingType.PRICE_ROUNDING_UP) {
            pointRoundingType = types_1.PointRoundingType.POINT_ROUNDING_DOWN;
        }
        return _xyPriceDecimal2Point(tokenB, tokenA, 1 / priceDecimalAByB, pointRoundingType);
    }
};
exports.priceDecimal2Point = priceDecimal2Point;
const priceUndecimal2Point = (tokenA, tokenB, priceUndecimalAByB, roundingType) => {
    if ((0, token_1.getSwapTokenAddress)(tokenA).toLowerCase() < (0, token_1.getSwapTokenAddress)(tokenB).toLowerCase()) {
        let pointRoundingType = types_1.PointRoundingType.POINT_ROUNDING_NEAREST;
        if (roundingType === types_1.PriceRoundingType.PRICE_ROUNDING_DOWN) {
            pointRoundingType = types_1.PointRoundingType.POINT_ROUNDING_DOWN;
        }
        if (roundingType === types_1.PriceRoundingType.PRICE_ROUNDING_UP) {
            pointRoundingType = types_1.PointRoundingType.POINT_ROUNDING_UP;
        }
        return _xyPriceUndecimal2Point(priceUndecimalAByB, pointRoundingType);
    }
    else {
        let pointRoundingType = types_1.PointRoundingType.POINT_ROUNDING_NEAREST;
        if (roundingType === types_1.PriceRoundingType.PRICE_ROUNDING_DOWN) {
            pointRoundingType = types_1.PointRoundingType.POINT_ROUNDING_UP;
        }
        if (roundingType === types_1.PriceRoundingType.PRICE_ROUNDING_UP) {
            pointRoundingType = types_1.PointRoundingType.POINT_ROUNDING_DOWN;
        }
        return _xyPriceUndecimal2Point(1 / priceUndecimalAByB, pointRoundingType);
    }
};
exports.priceUndecimal2Point = priceUndecimal2Point;
const point2PoolPriceUndecimalSqrt = (point) => {
    return Math.pow((Math.pow(1.0001, point)), 0.5);
};
exports.point2PoolPriceUndecimalSqrt = point2PoolPriceUndecimalSqrt;
const point2PriceUndecimal = (tokenA, tokenB, point) => {
    if ((0, token_1.getSwapTokenAddress)(tokenA).toLowerCase() < (0, token_1.getSwapTokenAddress)(tokenB).toLowerCase()) {
        return new bignumber_js_1.BigNumber(Math.pow(1.0001, point));
    }
    else {
        return new bignumber_js_1.BigNumber(1).div(Math.pow(1.0001, point));
    }
};
exports.point2PriceUndecimal = point2PriceUndecimal;
const getTokenXYFromToken = (tokenA, tokenB) => {
    if ((0, token_1.getSwapTokenAddress)(tokenA).toLowerCase() < (0, token_1.getSwapTokenAddress)(tokenB).toLowerCase()) {
        return {
            tokenX: Object.assign({}, tokenA),
            tokenY: Object.assign({}, tokenB)
        };
    }
    else {
        return {
            tokenX: Object.assign({}, tokenB),
            tokenY: Object.assign({}, tokenA)
        };
    }
};
exports.getTokenXYFromToken = getTokenXYFromToken;
const point2PriceDecimal = (tokenA, tokenB, point) => {
    let priceDecimal = 0;
    let needReverse = false;
    const { tokenX, tokenY } = (0, exports.getTokenXYFromToken)(tokenA, tokenB);
    if (point > 0) {
        priceDecimal = (0, exports.priceUndecimal2PriceDecimal)(tokenX, tokenY, new bignumber_js_1.BigNumber(Math.pow(1.0001, point)));
        needReverse = (0, token_1.getSwapTokenAddress)(tokenA).toLowerCase() > (0, token_1.getSwapTokenAddress)(tokenB).toLowerCase();
    }
    else {
        priceDecimal = (0, exports.priceUndecimal2PriceDecimal)(tokenY, tokenX, new bignumber_js_1.BigNumber(Math.pow(1.0001, (-point))));
        needReverse = (0, token_1.getSwapTokenAddress)(tokenA).toLowerCase() < (0, token_1.getSwapTokenAddress)(tokenB).toLowerCase();
    }
    if (needReverse) {
        priceDecimal = 1 / priceDecimal;
    }
    return priceDecimal;
};
exports.point2PriceDecimal = point2PriceDecimal;
const pointDeltaRoundingUp = (point, pointDelta) => {
    let mod = point % pointDelta;
    if (mod < 0) {
        mod += pointDelta;
    }
    if (mod === 0) {
        return point;
    }
    else {
        return point + pointDelta - mod;
    }
};
exports.pointDeltaRoundingUp = pointDeltaRoundingUp;
const pointDeltaRoundingDown = (point, pointDelta) => {
    let mod = point % pointDelta;
    if (mod < 0) {
        mod += pointDelta;
    }
    if (mod === 0) {
        return point;
    }
    else {
        return point - mod;
    }
};
exports.pointDeltaRoundingDown = pointDeltaRoundingDown;
