"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeMethodResult = exports.getTokenChainPathReverse = exports.getTokenChainPath = exports.parallelCollect = exports.getEVMContract = void 0;
const token_1 = require("./token");
const getEVMContract = (abi, address, web3) => {
    return new web3.eth.Contract(abi, address, {});
};
exports.getEVMContract = getEVMContract;
function num2Hex(n) {
    if (n < 10) {
        return String(n);
    }
    const str = 'ABCDEF';
    return str[n - 10];
}
function fee2Hex(fee) {
    const n0 = fee % 16;
    const n1 = Math.floor(fee / 16) % 16;
    const n2 = Math.floor(fee / 256) % 16;
    const n3 = Math.floor(fee / 4096) % 16;
    const n4 = 0;
    const n5 = 0;
    return '0x' + num2Hex(n5) + num2Hex(n4) + num2Hex(n3) + num2Hex(n2) + num2Hex(n1) + num2Hex(n0);
}
function appendHex(hexString, newHexString) {
    return hexString + newHexString.slice(2);
}
const parallelCollect = (...promiseList) => __awaiter(void 0, void 0, void 0, function* () {
    const results = Array(promiseList.length);
    for (const i in promiseList) {
        if (!promiseList[i]) {
            continue;
        }
        promiseList[i].then((r) => (results[i] = r));
    }
    yield Promise.all(promiseList);
    return results;
});
exports.parallelCollect = parallelCollect;
const getTokenChainPath = (tokenChain, feeChain) => {
    let hexString = (0, token_1.getSwapTokenAddress)(tokenChain[0]);
    for (let i = 0; i < feeChain.length; i++) {
        hexString = appendHex(hexString, fee2Hex(feeChain[i]));
        hexString = appendHex(hexString, (0, token_1.getSwapTokenAddress)(tokenChain[i + 1]));
    }
    return hexString;
};
exports.getTokenChainPath = getTokenChainPath;
const getTokenChainPathReverse = (tokenChain, feeChain) => {
    let hexString = (0, token_1.getSwapTokenAddress)(tokenChain[tokenChain.length - 1]);
    for (let i = feeChain.length - 1; i >= 0; i--) {
        hexString = appendHex(hexString, fee2Hex(feeChain[i]));
        hexString = appendHex(hexString, (0, token_1.getSwapTokenAddress)(tokenChain[i]));
    }
    return hexString;
};
exports.getTokenChainPathReverse = getTokenChainPathReverse;
function decodeMethodResult(contract, methodName, data) {
    const typeDefine = contract._jsonInterface.filter((a) => a['name'] === methodName)[0].outputs;
    return contract._decodeMethodReturn(typeDefine, data);
}
exports.decodeMethodResult = decodeMethodResult;
