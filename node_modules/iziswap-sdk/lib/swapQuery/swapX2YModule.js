"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SwapX2YModule = void 0;
const jsbi_1 = __importDefault(require("jsbi"));
const consts_1 = require("./library/consts");
const Orders_1 = require("./library/Orders");
const MulDivMath_1 = require("./library/MulDivMath");
const SwapMathX2Y_1 = require("./library/SwapMathX2Y");
const LogPowMath_1 = require("./library/LogPowMath");
const SwapMathX2YDesire_1 = require("./library/SwapMathX2YDesire");
const error_1 = require("./error");
var SwapX2YModule;
(function (SwapX2YModule) {
    function swapX2Y(pool, amount, lowPt) {
        (0, error_1.swapQueryInvariant)(jsbi_1.default.greaterThan(amount, consts_1.Consts.ZERO), error_1.SwapQueryErrCode.AMOUNT_ZERO_ERROR);
        lowPt = Math.max(lowPt, pool.leftMostPt);
        (0, error_1.swapQueryInvariant)(Orders_1.Orders.coverLowPoint(pool.orders, lowPt), error_1.SwapQueryErrCode.LOWPT_OVER_ORDER_RANGE_ERROR);
        let amountX = consts_1.Consts.ZERO;
        let amountY = consts_1.Consts.ZERO;
        const st = pool.state;
        (0, error_1.swapQueryInvariant)(lowPt <= st.currentPoint, error_1.SwapQueryErrCode.LOWPT_GREATER_THAN_CURRENTPT_ERROR);
        (0, error_1.swapQueryInvariant)(Orders_1.Orders.coverCurrentPoint(pool.orders, st.currentPoint), error_1.SwapQueryErrCode.CURRENTPT_OVER_ORDER_RANGE_ERROR);
        // const currFeeScaleX_128 = st.feeScaleX_128
        // const currFeeScaleY_128 = st.feeScaleY_128
        let finished = false;
        const sqrtRate_96 = pool.sqrtRate_96;
        // console.log('sqrt rate')
        const pointDelta = pool.pointDelta;
        let currentCursor = Orders_1.Orders.findLeftCursor(pool.orders, st.currentPoint);
        const fee = jsbi_1.default.BigInt(pool.fee);
        const feeRemain = jsbi_1.default.BigInt(1e6 - pool.fee);
        while (lowPt <= st.currentPoint && !finished) {
            // clear limit order first
            if (currentCursor.isLimitOrderPoint) {
                const amountNoFee = MulDivMath_1.MulDivMath.mulDivFloor(amount, feeRemain, consts_1.Consts.ONE_M);
                if (jsbi_1.default.greaterThan(amountNoFee, consts_1.Consts.ZERO)) {
                    const currY = pool.orders.sellingY[currentCursor.sellingIdx];
                    const { costX, acquireY } = SwapMathX2Y_1.SwapMathX2Y.x2YAtPrice(amountNoFee, st.sqrtPrice_96, currY);
                    if (jsbi_1.default.lessThan(acquireY, currY) || jsbi_1.default.greaterThanOrEqual(costX, amountNoFee)) {
                        finished = true;
                    }
                    let feeAmount = consts_1.Consts.ZERO;
                    if (jsbi_1.default.greaterThanOrEqual(costX, amountNoFee)) {
                        feeAmount = jsbi_1.default.subtract(amount, costX);
                    }
                    else {
                        feeAmount = MulDivMath_1.MulDivMath.mulDivCeil(costX, fee, feeRemain);
                    }
                    const cost = jsbi_1.default.add(costX, feeAmount);
                    amount = jsbi_1.default.subtract(amount, cost);
                    amountX = jsbi_1.default.add(amountX, cost);
                    amountY = jsbi_1.default.add(amountY, acquireY);
                }
                else {
                    finished = true;
                }
            }
            if (finished) {
                break;
            }
            const searchStart = st.currentPoint - 1;
            if (currentCursor.isLiquidityPoint) {
                const amountNoFee = MulDivMath_1.MulDivMath.mulDivFloor(amount, feeRemain, consts_1.Consts.ONE_M);
                if (jsbi_1.default.greaterThan(amountNoFee, consts_1.Consts.ZERO)) {
                    if (jsbi_1.default.greaterThan(st.liquidity, consts_1.Consts.ZERO)) {
                        const retState = SwapMathX2Y_1.SwapMathX2Y.x2YRange(st, st.currentPoint, sqrtRate_96, amountNoFee);
                        finished = retState.finished;
                        let feeAmount = consts_1.Consts.ZERO;
                        if (jsbi_1.default.greaterThanOrEqual(retState.costX, amountNoFee)) {
                            feeAmount = jsbi_1.default.subtract(amount, retState.costX);
                        }
                        else {
                            feeAmount = MulDivMath_1.MulDivMath.mulDivCeil(retState.costX, fee, feeRemain);
                        }
                        const cost = jsbi_1.default.add(retState.costX, feeAmount);
                        amountX = jsbi_1.default.add(amountX, cost);
                        amountY = jsbi_1.default.add(amountY, retState.acquireY);
                        amount = jsbi_1.default.subtract(amount, cost);
                        st.currentPoint = retState.finalPt;
                        st.sqrtPrice_96 = retState.sqrtFinalPrice_96;
                        st.liquidityX = retState.liquidityX;
                    }
                    if (!finished) {
                        st.currentPoint--;
                        if (st.currentPoint < lowPt) {
                            break;
                        }
                        st.sqrtPrice_96 = LogPowMath_1.LogPowMath.getSqrtPrice(st.currentPoint);
                        currentCursor = Orders_1.Orders.findLeftFromCursor(pool.orders, currentCursor, st.currentPoint);
                        st.liquidity = pool.orders.liquidity[currentCursor.liquidityIdx];
                        st.liquidityX = consts_1.Consts.ZERO;
                    }
                }
            }
            if (finished || st.currentPoint < lowPt) {
                break;
            }
            currentCursor = Orders_1.Orders.findLeftFromCursor(pool.orders, currentCursor, searchStart);
            const nextPt = Math.max(lowPt, Orders_1.Orders.nearestLeftOneOrBoundary(pool.orders, currentCursor, searchStart, pointDelta));
            if (jsbi_1.default.equal(st.liquidity, consts_1.Consts.ZERO)) {
                st.currentPoint = nextPt;
                st.sqrtPrice_96 = LogPowMath_1.LogPowMath.getSqrtPrice(st.currentPoint);
                currentCursor = Orders_1.Orders.findLeftFromCursor(pool.orders, currentCursor, st.currentPoint);
            }
            else {
                const amountNoFee = MulDivMath_1.MulDivMath.mulDivFloor(amount, feeRemain, consts_1.Consts.ONE_M);
                if (jsbi_1.default.greaterThan(amountNoFee, consts_1.Consts.ZERO)) {
                    const retState = SwapMathX2Y_1.SwapMathX2Y.x2YRange(st, nextPt, sqrtRate_96, amountNoFee);
                    finished = retState.finished;
                    let feeAmount = consts_1.Consts.ZERO;
                    if (jsbi_1.default.greaterThanOrEqual(retState.costX, amountNoFee)) {
                        feeAmount = jsbi_1.default.subtract(amount, retState.costX);
                    }
                    else {
                        feeAmount = MulDivMath_1.MulDivMath.mulDivCeil(retState.costX, fee, feeRemain);
                    }
                    amountY = jsbi_1.default.add(amountY, retState.acquireY);
                    const cost = jsbi_1.default.add(retState.costX, feeAmount);
                    amountX = jsbi_1.default.add(amountX, cost);
                    amount = jsbi_1.default.subtract(amount, cost);
                    st.currentPoint = retState.finalPt;
                    st.sqrtPrice_96 = retState.sqrtFinalPrice_96;
                    st.liquidityX = retState.liquidityX;
                }
                else {
                    finished = true;
                }
                currentCursor = Orders_1.Orders.findLeftFromCursor(pool.orders, currentCursor, st.currentPoint);
                st.liquidity = pool.orders.liquidity[currentCursor.liquidityIdx];
            }
            if (st.currentPoint <= lowPt) {
                break;
            }
        }
        return { amountX, amountY };
    }
    SwapX2YModule.swapX2Y = swapX2Y;
    function swapX2YDesireY(pool, desireY, lowPt) {
        (0, error_1.swapQueryInvariant)(jsbi_1.default.greaterThan(desireY, consts_1.Consts.ZERO), error_1.SwapQueryErrCode.AMOUNT_ZERO_ERROR);
        lowPt = Math.max(lowPt, pool.leftMostPt);
        (0, error_1.swapQueryInvariant)(Orders_1.Orders.coverLowPoint(pool.orders, lowPt), error_1.SwapQueryErrCode.LOWPT_OVER_ORDER_RANGE_ERROR);
        let amountX = consts_1.Consts.ZERO;
        let amountY = consts_1.Consts.ZERO;
        const st = pool.state;
        (0, error_1.swapQueryInvariant)(lowPt <= st.currentPoint, error_1.SwapQueryErrCode.LOWPT_GREATER_THAN_CURRENTPT_ERROR);
        (0, error_1.swapQueryInvariant)(Orders_1.Orders.coverCurrentPoint(pool.orders, st.currentPoint), error_1.SwapQueryErrCode.CURRENTPT_OVER_ORDER_RANGE_ERROR);
        // const currFeeScaleX_128 = st.feeScaleX_128
        // const currFeeScaleY_128 = st.feeScaleY_128
        let finished = false;
        const sqrtRate_96 = pool.sqrtRate_96;
        const pointDelta = pool.pointDelta;
        let currentCursor = Orders_1.Orders.findLeftCursor(pool.orders, st.currentPoint);
        const fee = jsbi_1.default.BigInt(pool.fee);
        const feeRemain = jsbi_1.default.BigInt(1e6 - pool.fee);
        while (lowPt <= st.currentPoint && !finished) {
            // clear limit order first
            if (currentCursor.isLimitOrderPoint) {
                const currY = pool.orders.sellingY[currentCursor.sellingIdx];
                const { costX, acquireY } = SwapMathX2YDesire_1.SwapMathX2YDesire.x2YAtPrice(desireY, st.sqrtPrice_96, currY);
                if (jsbi_1.default.greaterThanOrEqual(acquireY, desireY)) {
                    finished = true;
                }
                const feeAmount = MulDivMath_1.MulDivMath.mulDivCeil(costX, fee, feeRemain);
                const cost = jsbi_1.default.add(costX, feeAmount);
                desireY = jsbi_1.default.subtract(desireY, acquireY);
                amountX = jsbi_1.default.add(amountX, cost);
                amountY = jsbi_1.default.add(amountY, acquireY);
            }
            if (finished) {
                break;
            }
            const searchStart = st.currentPoint - 1;
            if (currentCursor.isLiquidityPoint) {
                if (jsbi_1.default.greaterThan(st.liquidity, consts_1.Consts.ZERO)) {
                    const retState = SwapMathX2YDesire_1.SwapMathX2YDesire.x2YRange(st, st.currentPoint, sqrtRate_96, desireY);
                    finished = retState.finished;
                    const feeAmount = MulDivMath_1.MulDivMath.mulDivCeil(retState.costX, fee, feeRemain);
                    const cost = jsbi_1.default.add(retState.costX, feeAmount);
                    amountX = jsbi_1.default.add(amountX, cost);
                    amountY = jsbi_1.default.add(amountY, retState.acquireY);
                    desireY = jsbi_1.default.subtract(desireY, retState.acquireY);
                    st.currentPoint = retState.finalPt;
                    st.sqrtPrice_96 = retState.sqrtFinalPrice_96;
                    st.liquidityX = retState.liquidityX;
                }
                if (!finished) {
                    st.currentPoint--;
                    if (st.currentPoint < lowPt) {
                        break;
                    }
                    st.sqrtPrice_96 = LogPowMath_1.LogPowMath.getSqrtPrice(st.currentPoint);
                    currentCursor = Orders_1.Orders.findLeftFromCursor(pool.orders, currentCursor, st.currentPoint);
                    st.liquidity = pool.orders.liquidity[currentCursor.liquidityIdx];
                    st.liquidityX = consts_1.Consts.ZERO;
                }
            }
            if (finished || st.currentPoint < lowPt) {
                break;
            }
            currentCursor = Orders_1.Orders.findLeftFromCursor(pool.orders, currentCursor, searchStart);
            const nextPt = Math.max(lowPt, Orders_1.Orders.nearestLeftOneOrBoundary(pool.orders, currentCursor, searchStart, pointDelta));
            if (jsbi_1.default.equal(st.liquidity, consts_1.Consts.ZERO)) {
                st.currentPoint = nextPt;
                st.sqrtPrice_96 = LogPowMath_1.LogPowMath.getSqrtPrice(st.currentPoint);
                currentCursor = Orders_1.Orders.findLeftFromCursor(pool.orders, currentCursor, st.currentPoint);
            }
            else {
                const retState = SwapMathX2YDesire_1.SwapMathX2YDesire.x2YRange(st, nextPt, sqrtRate_96, desireY);
                finished = retState.finished;
                const feeAmount = MulDivMath_1.MulDivMath.mulDivCeil(retState.costX, fee, feeRemain);
                amountY = jsbi_1.default.add(amountY, retState.acquireY);
                const cost = jsbi_1.default.add(retState.costX, feeAmount);
                amountX = jsbi_1.default.add(amountX, cost);
                desireY = jsbi_1.default.subtract(desireY, retState.acquireY);
                st.currentPoint = retState.finalPt;
                st.sqrtPrice_96 = retState.sqrtFinalPrice_96;
                st.liquidityX = retState.liquidityX;
                currentCursor = Orders_1.Orders.findLeftFromCursor(pool.orders, currentCursor, st.currentPoint);
                st.liquidity = pool.orders.liquidity[currentCursor.liquidityIdx];
            }
            if (st.currentPoint <= lowPt) {
                break;
            }
        }
        return { amountX, amountY };
    }
    SwapX2YModule.swapX2YDesireY = swapX2YDesireY;
})(SwapX2YModule = exports.SwapX2YModule || (exports.SwapX2YModule = {}));
