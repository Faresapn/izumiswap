"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SwapMathY2XDesire = void 0;
const jsbi_1 = __importDefault(require("jsbi"));
const MaxMinMath_1 = require("./MaxMinMath");
const MulDivMath_1 = require("./MulDivMath");
const consts_1 = require("./consts");
const Converter_1 = require("./Converter");
const AmountMath_1 = require("./AmountMath");
const LogPowMath_1 = require("./LogPowMath");
var SwapMathY2XDesire;
(function (SwapMathY2XDesire) {
    function y2XAtPrice(desireX, sqrtPrice_96, currX) {
        const acquireX = MaxMinMath_1.MaxMinMath.min(desireX, currX);
        const l = MulDivMath_1.MulDivMath.mulDivCeil(acquireX, sqrtPrice_96, consts_1.Consts.Q96);
        const costY = Converter_1.Converter.toUint128(MulDivMath_1.MulDivMath.mulDivCeil(l, sqrtPrice_96, consts_1.Consts.Q96));
        return { costY, acquireX };
    }
    SwapMathY2XDesire.y2XAtPrice = y2XAtPrice;
    function y2XAtPriceLiquidity(desireX, sqrtPrice_96, liquidityX) {
        const maxTransformLiquidityY = MulDivMath_1.MulDivMath.mulDivCeil(desireX, sqrtPrice_96, consts_1.Consts.Q96);
        // transformLiquidityY <= liquidityX <= uint128.max
        const transformLiquidityY = MaxMinMath_1.MaxMinMath.min(maxTransformLiquidityY, liquidityX);
        const costY = MulDivMath_1.MulDivMath.mulDivCeil(transformLiquidityY, sqrtPrice_96, consts_1.Consts.Q96);
        // transformLiquidityY * TwoPower.Pow96 < 2^128 * 2^96 = 2^224 < 2^256
        const acquireX = Converter_1.Converter.toUint128(MulDivMath_1.MulDivMath.mulDivFloor(transformLiquidityY, consts_1.Consts.Q96, sqrtPrice_96));
        const newLiquidityX = jsbi_1.default.subtract(liquidityX, transformLiquidityY);
        return { costY, acquireX, newLiquidityX };
    }
    SwapMathY2XDesire.y2XAtPriceLiquidity = y2XAtPriceLiquidity;
    function y2XRangeComplete(rg, desireX) {
        const ret = {};
        const maxX = AmountMath_1.AmountMath._getAmountX(rg.liquidity, rg.leftPt, rg.rightPt, rg.sqrtPriceR_96, rg.sqrtRate_96, false);
        if (jsbi_1.default.lessThanOrEqual(maxX, desireX)) {
            // maxX <= desireX <= uint128.max
            ret.acquireX = maxX;
            ret.costY = AmountMath_1.AmountMath._getAmountY(rg.liquidity, rg.sqrtPriceL_96, rg.sqrtPriceR_96, rg.sqrtRate_96, true);
            ret.completeLiquidity = true;
            return ret;
        }
        const sqrtPricePrPl_96 = LogPowMath_1.LogPowMath.getSqrtPrice(rg.rightPt - rg.leftPt);
        // rg.sqrtPriceR_96 * 2^96 < 2^160 * 2^96 = 2^256
        const sqrtPricePrM1_96 = MulDivMath_1.MulDivMath.mulDivFloor(rg.sqrtPriceR_96, consts_1.Consts.Q96, rg.sqrtRate_96);
        // div must be > 2^96 because, if
        //  div <= 2^96
        //  <=>  sqrtPricePrPl_96 - desireX * (sqrtPriceR_96 - sqrtPricePrM1_96) / liquidity <= 2^96 (here, '/' is div of int)
        //  <=>  desireX >= (sqrtPricePrPl_96 - 2^96) * liquidity / (sqrtPriceR_96 - sqrtPricePrM1_96) 
        //  <=>  desireX >= maxX
        //  will enter the branch above and return
        const div = jsbi_1.default.subtract(sqrtPricePrPl_96, MulDivMath_1.MulDivMath.mulDivFloor(desireX, jsbi_1.default.subtract(rg.sqrtPriceR_96, sqrtPricePrM1_96), rg.liquidity));
        // 1. rg.sqrtPriceR_96 * 2^96 < 2^160 * 2^96 = 2^256
        // 2. sqrtPriceLoc_96 must < rg.sqrtPriceR_96, because div > 2^96
        const sqrtPriceLoc_96 = MulDivMath_1.MulDivMath.mulDivFloor(rg.sqrtPriceR_96, consts_1.Consts.Q96, div);
        ret.completeLiquidity = false;
        ret.locPt = LogPowMath_1.LogPowMath.getLogSqrtPriceFloor(sqrtPriceLoc_96);
        ret.locPt = Math.max(rg.leftPt, ret.locPt);
        ret.locPt = Math.min(rg.rightPt - 1, ret.locPt);
        ret.sqrtLoc_96 = LogPowMath_1.LogPowMath.getSqrtPrice(ret.locPt);
        if (ret.locPt === rg.leftPt) {
            ret.acquireX = consts_1.Consts.ZERO;
            ret.costY = consts_1.Consts.ZERO;
            return ret;
        }
        ret.completeLiquidity = false;
        // ret.acquireX <= desireX <= uint128.max
        ret.acquireX = MaxMinMath_1.MaxMinMath.min(AmountMath_1.AmountMath._getAmountX(rg.liquidity, rg.leftPt, ret.locPt, ret.sqrtLoc_96, rg.sqrtRate_96, false), desireX);
        ret.costY = AmountMath_1.AmountMath._getAmountY(rg.liquidity, rg.sqrtPriceL_96, ret.sqrtLoc_96, rg.sqrtRate_96, true);
        return ret;
    }
    function y2XRange(currentState, rightPt, sqrtRate_96, originDesireX) {
        const retState = {};
        retState.costY = consts_1.Consts.ZERO;
        retState.acquireX = consts_1.Consts.ZERO;
        retState.finished = false;
        let desireX = originDesireX;
        // first, if current point is not all x, we can not move right directly
        const startHasY = jsbi_1.default.lessThan(currentState.liquidityX, currentState.liquidity);
        if (startHasY) {
            const { costY, acquireX, newLiquidityX } = y2XAtPriceLiquidity(desireX, currentState.sqrtPrice_96, currentState.liquidityX);
            retState.costY = costY;
            retState.acquireX = acquireX;
            retState.liquidityX = newLiquidityX;
            if (jsbi_1.default.notEqual(retState.liquidityX, consts_1.Consts.ZERO) || jsbi_1.default.greaterThanOrEqual(retState.acquireX, desireX)) {
                // currX remain, means desire runout
                retState.finished = true;
                retState.finalPt = currentState.currentPoint;
                retState.sqrtFinalPrice_96 = currentState.sqrtPrice_96;
                return retState;
            }
            else {
                // not finished
                desireX = jsbi_1.default.subtract(desireX, retState.acquireX);
                currentState.currentPoint += 1;
                if (currentState.currentPoint == rightPt) {
                    retState.finalPt = currentState.currentPoint;
                    // get fixed sqrt price to reduce accumulated error
                    retState.sqrtFinalPrice_96 = LogPowMath_1.LogPowMath.getSqrtPrice(rightPt);
                    return retState;
                }
                // sqrt(price) + sqrt(price) * (1.0001 - 1) == sqrt(price) * 1.0001
                currentState.sqrtPrice_96 = jsbi_1.default.add(currentState.sqrtPrice_96, MulDivMath_1.MulDivMath.mulDivFloor(currentState.sqrtPrice_96, jsbi_1.default.subtract(sqrtRate_96, consts_1.Consts.Q96), consts_1.Consts.Q96));
            }
        }
        const sqrtPriceR_96 = LogPowMath_1.LogPowMath.getSqrtPrice(rightPt);
        const ret = y2XRangeComplete({
            liquidity: currentState.liquidity,
            sqrtPriceL_96: currentState.sqrtPrice_96,
            leftPt: currentState.currentPoint,
            sqrtPriceR_96: sqrtPriceR_96,
            rightPt: rightPt,
            sqrtRate_96: sqrtRate_96
        }, desireX);
        retState.costY = jsbi_1.default.add(retState.costY, ret.costY);
        retState.acquireX = jsbi_1.default.add(retState.acquireX, ret.acquireX);
        desireX = jsbi_1.default.subtract(desireX, ret.acquireX);
        if (ret.completeLiquidity) {
            retState.finished = jsbi_1.default.equal(desireX, consts_1.Consts.ZERO);
            retState.finalPt = rightPt;
            retState.sqrtFinalPrice_96 = sqrtPriceR_96;
        }
        else {
            const { costY: locCostY, acquireX: locAcquireX, newLiquidityX } = y2XAtPriceLiquidity(desireX, ret.sqrtLoc_96, currentState.liquidity);
            retState.liquidityX = newLiquidityX;
            retState.costY = jsbi_1.default.add(retState.costY, locCostY);
            retState.acquireX = jsbi_1.default.add(retState.acquireX, locAcquireX);
            retState.finished = true;
            retState.finalPt = ret.locPt;
            retState.sqrtFinalPrice_96 = ret.sqrtLoc_96;
        }
        return retState;
    }
    SwapMathY2XDesire.y2XRange = y2XRange;
})(SwapMathY2XDesire = exports.SwapMathY2XDesire || (exports.SwapMathY2XDesire = {}));
