"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SwapMathX2YDesire = void 0;
const jsbi_1 = __importDefault(require("jsbi"));
const MulDivMath_1 = require("./MulDivMath");
const consts_1 = require("./consts");
const Converter_1 = require("./Converter");
const MaxMinMath_1 = require("./MaxMinMath");
const AmountMath_1 = require("./AmountMath");
const LogPowMath_1 = require("./LogPowMath");
var SwapMathX2YDesire;
(function (SwapMathX2YDesire) {
    function x2YAtPrice(desireY, sqrtPrice_96, currY) {
        let acquireY = desireY;
        if (jsbi_1.default.greaterThan(acquireY, currY)) {
            acquireY = currY;
        }
        const l = MulDivMath_1.MulDivMath.mulDivCeil(acquireY, consts_1.Consts.Q96, sqrtPrice_96);
        const costX = Converter_1.Converter.toUint128(MulDivMath_1.MulDivMath.mulDivCeil(l, consts_1.Consts.Q96, sqrtPrice_96));
        return { costX, acquireY };
    }
    SwapMathX2YDesire.x2YAtPrice = x2YAtPrice;
    function x2YAtPriceLiquidity(desireY, sqrtPrice_96, liquidity, liquidityX) {
        const liquidityY = jsbi_1.default.subtract(liquidity, liquidityX);
        const maxTransformLiquidityX = MulDivMath_1.MulDivMath.mulDivCeil(desireY, consts_1.Consts.Q96, sqrtPrice_96);
        // transformLiquidityX <= liquidityY <= uint128.max
        const transformLiquidityX = MaxMinMath_1.MaxMinMath.min(maxTransformLiquidityX, liquidityY);
        // transformLiquidityX * 2^96 <= 2^128 * 2^96 <= 2^224 < 2^256
        const costX = MulDivMath_1.MulDivMath.mulDivCeil(transformLiquidityX, consts_1.Consts.Q96, sqrtPrice_96);
        // acquireY should not > uint128.max
        const acquireY256 = MulDivMath_1.MulDivMath.mulDivFloor(transformLiquidityX, sqrtPrice_96, consts_1.Consts.Q96);
        const acquireY = Converter_1.Converter.toUint128(acquireY256);
        const newLiquidityX = jsbi_1.default.add(liquidityX, transformLiquidityX);
        return { costX, acquireY, newLiquidityX };
    }
    SwapMathX2YDesire.x2YAtPriceLiquidity = x2YAtPriceLiquidity;
    function x2YRangeComplete(rg, desireY) {
        const ret = {};
        const maxY = AmountMath_1.AmountMath._getAmountY(rg.liquidity, rg.sqrtPriceL_96, rg.sqrtPriceR_96, rg.sqrtRate_96, false);
        if (jsbi_1.default.lessThanOrEqual(maxY, desireY)) {
            ret.acquireY = maxY;
            ret.costX = AmountMath_1.AmountMath._getAmountX(rg.liquidity, rg.leftPt, rg.rightPt, rg.sqrtPriceR_96, rg.sqrtRate_96, true);
            ret.completeLiquidity = true;
            return ret;
        }
        const cl = jsbi_1.default.subtract(rg.sqrtPriceR_96, MulDivMath_1.MulDivMath.mulDivFloor(desireY, jsbi_1.default.subtract(rg.sqrtRate_96, consts_1.Consts.Q96), rg.liquidity));
        ret.locPt = LogPowMath_1.LogPowMath.getLogSqrtPriceFloor(cl) + 1;
        ret.locPt = Math.min(ret.locPt, rg.rightPt);
        ret.locPt = Math.max(ret.locPt, rg.leftPt + 1);
        ret.completeLiquidity = false;
        if (ret.locPt === rg.rightPt) {
            ret.costX = consts_1.Consts.ZERO;
            ret.acquireY = consts_1.Consts.ZERO;
            ret.locPt = ret.locPt - 1;
            ret.sqrtLoc_96 = LogPowMath_1.LogPowMath.getSqrtPrice(ret.locPt);
        }
        else {
            // rg.rightPt - ret.locPt <= 256 * 100
            // sqrtPricePrMloc_96 <= 1.0001 ** 25600 * 2 ^ 96 = 13 * 2^96 < 2^100
            const sqrtPricePrMloc_96 = LogPowMath_1.LogPowMath.getSqrtPrice(rg.rightPt - ret.locPt);
            // rg.sqrtPriceR_96 * TwoPower.Pow96 < 2^160 * 2^96 = 2^256
            const sqrtPricePrM1_96 = MulDivMath_1.MulDivMath.mulDivCeil(rg.sqrtPriceR_96, consts_1.Consts.Q96, rg.sqrtRate_96);
            // rg.liquidity * (sqrtPricePrMloc_96 - TwoPower.Pow96) < 2^128 * 2^100 = 2^228 < 2^256
            ret.costX = MulDivMath_1.MulDivMath.mulDivCeil(rg.liquidity, jsbi_1.default.subtract(sqrtPricePrMloc_96, consts_1.Consts.Q96), jsbi_1.default.subtract(rg.sqrtPriceR_96, sqrtPricePrM1_96));
            ret.locPt = ret.locPt - 1;
            ret.sqrtLoc_96 = LogPowMath_1.LogPowMath.getSqrtPrice(ret.locPt);
            const sqrtLocA1_96 = jsbi_1.default.add(ret.sqrtLoc_96, MulDivMath_1.MulDivMath.mulDivCeil(ret.sqrtLoc_96, jsbi_1.default.subtract(rg.sqrtRate_96, consts_1.Consts.Q96), consts_1.Consts.Q96));
            ret.acquireY = AmountMath_1.AmountMath._getAmountY(rg.liquidity, sqrtLocA1_96, rg.sqrtPriceR_96, rg.sqrtRate_96, false);
            // ret.acquireY <= desireY <= uint128.max
        }
        return ret;
    }
    function x2YRange(currentState, leftPt, sqrtRate_96, originDesireY) {
        const retState = {};
        retState.costX = consts_1.Consts.ZERO;
        retState.acquireY = consts_1.Consts.ZERO;
        retState.finished = false;
        let desireY = originDesireY;
        const currentHasY = jsbi_1.default.lessThan(currentState.liquidityX, currentState.liquidity);
        if (currentHasY && (jsbi_1.default.greaterThan(currentState.liquidityX, consts_1.Consts.ZERO) || leftPt === currentState.currentPoint)) {
            const { costX, acquireY, newLiquidityX } = x2YAtPriceLiquidity(desireY, currentState.sqrtPrice_96, currentState.liquidity, currentState.liquidityX);
            retState.costX = costX;
            retState.acquireY = acquireY;
            retState.liquidityX = newLiquidityX;
            if (jsbi_1.default.lessThan(retState.liquidityX, currentState.liquidity) || jsbi_1.default.greaterThanOrEqual(retState.acquireY, desireY)) {
                // remaining desire y is not enough to down current price to price / 1.0001
                // but desire y may remain, so we cannot simply use (retState.acquireY >= desireY)
                retState.finished = true;
                retState.finalPt = currentState.currentPoint;
                retState.sqrtFinalPrice_96 = currentState.sqrtPrice_96;
            }
            else {
                desireY = jsbi_1.default.subtract(desireY, retState.acquireY);
            }
        }
        else if (currentHasY) { // all y
            currentState.currentPoint = currentState.currentPoint + 1;
            // sqrt(price) + sqrt(price) * (1.0001 - 1) == sqrt(price) * 1.0001
            currentState.sqrtPrice_96 = jsbi_1.default.add(currentState.sqrtPrice_96, MulDivMath_1.MulDivMath.mulDivFloor(currentState.sqrtPrice_96, jsbi_1.default.subtract(sqrtRate_96, consts_1.Consts.Q96), consts_1.Consts.Q96));
        }
        else {
            retState.liquidityX = currentState.liquidityX;
        }
        if (retState.finished) {
            return retState;
        }
        if (leftPt < currentState.currentPoint) {
            const sqrtPriceL_96 = LogPowMath_1.LogPowMath.getSqrtPrice(leftPt);
            const ret = x2YRangeComplete({
                liquidity: currentState.liquidity,
                sqrtPriceL_96: sqrtPriceL_96,
                leftPt: leftPt,
                sqrtPriceR_96: currentState.sqrtPrice_96,
                rightPt: currentState.currentPoint,
                sqrtRate_96: sqrtRate_96
            }, desireY);
            retState.costX = jsbi_1.default.add(retState.costX, ret.costX);
            desireY = jsbi_1.default.subtract(desireY, ret.acquireY);
            retState.acquireY = jsbi_1.default.add(retState.acquireY, ret.acquireY);
            if (ret.completeLiquidity) {
                retState.finished = jsbi_1.default.equal(desireY, consts_1.Consts.ZERO);
                retState.finalPt = leftPt;
                retState.sqrtFinalPrice_96 = sqrtPriceL_96;
                retState.liquidityX = currentState.liquidity;
            }
            else {
                // trade at locPt
                const { costX: locCostX, acquireY: locAcquireY, newLiquidityX } = x2YAtPriceLiquidity(desireY, ret.sqrtLoc_96, currentState.liquidity, consts_1.Consts.ZERO);
                retState.liquidityX = newLiquidityX;
                retState.costX = jsbi_1.default.add(retState.costX, locCostX);
                retState.acquireY = jsbi_1.default.add(retState.acquireY, locAcquireY);
                retState.finished = true;
                retState.sqrtFinalPrice_96 = ret.sqrtLoc_96;
                retState.finalPt = ret.locPt;
            }
        }
        else {
            // finishd must be false
            // retState.finished == false;
            retState.finalPt = currentState.currentPoint;
            retState.sqrtFinalPrice_96 = currentState.sqrtPrice_96;
        }
        return retState;
    }
    SwapMathX2YDesire.x2YRange = x2YRange;
})(SwapMathX2YDesire = exports.SwapMathX2YDesire || (exports.SwapMathX2YDesire = {}));
