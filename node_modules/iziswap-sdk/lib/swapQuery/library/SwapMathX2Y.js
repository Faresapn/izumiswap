"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SwapMathX2Y = void 0;
const jsbi_1 = __importDefault(require("jsbi"));
const Converter_1 = require("./Converter");
const MulDivMath_1 = require("./MulDivMath");
const MaxMinMath_1 = require("./MaxMinMath");
const consts_1 = require("./consts");
const LogPowMath_1 = require("./LogPowMath");
const AmountMath_1 = require("./AmountMath");
var SwapMathX2Y;
(function (SwapMathX2Y) {
    function x2YAtPrice(amountX, sqrtPrice_96, currY) {
        let l = MulDivMath_1.MulDivMath.mulDivFloor(amountX, sqrtPrice_96, consts_1.Consts.Q96);
        let acquireY = Converter_1.Converter.toUint128(MulDivMath_1.MulDivMath.mulDivFloor(l, sqrtPrice_96, consts_1.Consts.Q96));
        if (jsbi_1.default.greaterThan(acquireY, currY)) {
            acquireY = currY;
        }
        l = MulDivMath_1.MulDivMath.mulDivCeil(acquireY, consts_1.Consts.Q96, sqrtPrice_96);
        const costX = MulDivMath_1.MulDivMath.mulDivCeil(l, consts_1.Consts.Q96, sqrtPrice_96);
        return { costX, acquireY };
    }
    SwapMathX2Y.x2YAtPrice = x2YAtPrice;
    function x2YAtPriceLiquidity(amountX, sqrtPrice_96, liquidity, liquidityX) {
        const liquidityY = jsbi_1.default.add(liquidity, jsbi_1.default.unaryMinus(liquidityX));
        const maxTransformLiquidityX = MulDivMath_1.MulDivMath.mulDivFloor(amountX, sqrtPrice_96, consts_1.Consts.Q96);
        const transformLiquidityX = MaxMinMath_1.MaxMinMath.min(maxTransformLiquidityX, liquidityY);
        const costX = MulDivMath_1.MulDivMath.mulDivCeil(transformLiquidityX, consts_1.Consts.Q96, sqrtPrice_96);
        const acquireY = MulDivMath_1.MulDivMath.mulDivFloor(transformLiquidityX, sqrtPrice_96, consts_1.Consts.Q96);
        const newLiquidityX = jsbi_1.default.add(liquidityX, transformLiquidityX);
        return { costX, acquireY, newLiquidityX };
    }
    function x2YRangeComplete(rg, amountX) {
        const ret = {};
        const sqrtPricePrM1_96 = MulDivMath_1.MulDivMath.mulDivCeil(rg.sqrtPriceR_96, consts_1.Consts.Q96, rg.sqrtRate_96);
        const sqrtPricePrMl_96 = LogPowMath_1.LogPowMath.getSqrtPrice(rg.rightPt - rg.leftPt);
        const maxX = MulDivMath_1.MulDivMath.mulDivCeil(rg.liquidity, jsbi_1.default.add(sqrtPricePrMl_96, jsbi_1.default.unaryMinus(consts_1.Consts.Q96)), jsbi_1.default.add(rg.sqrtPriceR_96, jsbi_1.default.unaryMinus(sqrtPricePrM1_96)));
        if (jsbi_1.default.lessThanOrEqual(maxX, amountX)) {
            ret.costX = maxX;
            ret.acquireY = AmountMath_1.AmountMath._getAmountY(rg.liquidity, rg.sqrtPriceL_96, rg.sqrtPriceR_96, rg.sqrtRate_96, false);
            ret.completeLiquidity = true;
        }
        else {
            const sqrtValue_96 = jsbi_1.default.add(MulDivMath_1.MulDivMath.mulDivFloor(amountX, jsbi_1.default.subtract(rg.sqrtPriceR_96, sqrtPricePrM1_96), rg.liquidity), consts_1.Consts.Q96);
            const logValue = LogPowMath_1.LogPowMath.getLogSqrtPriceFloor(sqrtValue_96);
            ret.locPt = rg.rightPt - logValue;
            ret.locPt = Math.min(ret.locPt, rg.rightPt);
            ret.locPt = Math.max(ret.locPt, rg.leftPt + 1);
            ret.completeLiquidity = false;
            if (ret.locPt === rg.rightPt) {
                ret.costX = consts_1.Consts.ZERO;
                ret.acquireY = consts_1.Consts.ZERO;
                ret.locPt = ret.locPt - 1;
                ret.sqrtLoc_96 = LogPowMath_1.LogPowMath.getSqrtPrice(ret.locPt);
            }
            else {
                const sqrtPricePrMloc_96 = LogPowMath_1.LogPowMath.getSqrtPrice(rg.rightPt - ret.locPt);
                ret.costX = MulDivMath_1.MulDivMath.mulDivCeil(rg.liquidity, jsbi_1.default.subtract(sqrtPricePrMloc_96, consts_1.Consts.Q96), jsbi_1.default.subtract(rg.sqrtPriceR_96, sqrtPricePrM1_96));
                ret.costX = MaxMinMath_1.MaxMinMath.min(ret.costX, amountX);
                ret.locPt = ret.locPt - 1;
                ret.sqrtLoc_96 = LogPowMath_1.LogPowMath.getSqrtPrice(ret.locPt);
                const sqrtLocA1_96 = jsbi_1.default.add(ret.sqrtLoc_96, MulDivMath_1.MulDivMath.mulDivFloor(ret.sqrtLoc_96, jsbi_1.default.subtract(rg.sqrtRate_96, consts_1.Consts.Q96), consts_1.Consts.Q96));
                ret.acquireY = AmountMath_1.AmountMath._getAmountY(rg.liquidity, sqrtLocA1_96, rg.sqrtPriceR_96, rg.sqrtRate_96, false);
            }
        }
        return ret;
    }
    function x2YRange(currentState, leftPt, sqrtRate_96, originAmountX) {
        const retState = {};
        retState.costX = consts_1.Consts.ZERO;
        retState.acquireY = consts_1.Consts.ZERO;
        retState.finished = false;
        const currentHasY = jsbi_1.default.lessThan(currentState.liquidityX, currentState.liquidity);
        let amountX = jsbi_1.default.BigInt(originAmountX);
        if (currentHasY && (jsbi_1.default.notEqual(currentState.liquidityX, consts_1.Consts.ZERO) || leftPt === currentState.currentPoint)) {
            const { costX, acquireY, newLiquidityX } = x2YAtPriceLiquidity(amountX, currentState.sqrtPrice_96, currentState.liquidity, currentState.liquidityX);
            retState.costX = costX;
            retState.acquireY = acquireY;
            retState.liquidityX = newLiquidityX;
            if (jsbi_1.default.LT(retState.liquidityX, currentState.liquidity) || jsbi_1.default.GE(retState.costX, amountX)) {
                // remaining x is not enough to down current price to price / 1.0001
                // but x may remain, so we cannot simply use (costX == amountX)
                retState.finished = true;
                retState.finalPt = currentState.currentPoint;
                retState.sqrtFinalPrice_96 = currentState.sqrtPrice_96;
            }
            else {
                amountX = jsbi_1.default.subtract(amountX, retState.costX);
            }
        }
        else if (currentHasY) { // all y
            currentState.currentPoint = currentState.currentPoint + 1;
            // sqrt(price) + sqrt(price) * (1.0001 - 1) == sqrt(price) * 1.0001
            currentState.sqrtPrice_96 = jsbi_1.default.add(currentState.sqrtPrice_96, MulDivMath_1.MulDivMath.mulDivFloor(currentState.sqrtPrice_96, jsbi_1.default.subtract(sqrtRate_96, consts_1.Consts.Q96), consts_1.Consts.Q96));
        }
        else {
            retState.liquidityX = currentState.liquidityX;
        }
        if (retState.finished) {
            return retState;
        }
        if (leftPt < currentState.currentPoint) {
            const sqrtPriceL_96 = LogPowMath_1.LogPowMath.getSqrtPrice(leftPt);
            const ret = x2YRangeComplete({
                liquidity: currentState.liquidity,
                sqrtPriceL_96: sqrtPriceL_96,
                leftPt: leftPt,
                sqrtPriceR_96: currentState.sqrtPrice_96,
                rightPt: currentState.currentPoint,
                sqrtRate_96: sqrtRate_96
            }, amountX);
            retState.costX = jsbi_1.default.add(retState.costX, ret.costX);
            amountX = jsbi_1.default.subtract(amountX, ret.costX);
            retState.acquireY = jsbi_1.default.add(retState.acquireY, ret.acquireY);
            if (ret.completeLiquidity) {
                retState.finished = jsbi_1.default.equal(amountX, consts_1.Consts.ZERO);
                retState.finalPt = leftPt;
                retState.sqrtFinalPrice_96 = sqrtPriceL_96;
                retState.liquidityX = currentState.liquidity;
            }
            else {
                const { costX: locCostX, acquireY: locAcquireY, newLiquidityX: retLiquidityX } = x2YAtPriceLiquidity(amountX, ret.sqrtLoc_96, currentState.liquidity, consts_1.Consts.ZERO);
                retState.liquidityX = retLiquidityX;
                retState.costX = jsbi_1.default.add(retState.costX, locCostX);
                retState.acquireY = jsbi_1.default.add(retState.acquireY, locAcquireY);
                retState.finished = true;
                retState.sqrtFinalPrice_96 = ret.sqrtLoc_96;
                retState.finalPt = ret.locPt;
            }
        }
        else {
            // finishd must be false
            // retState.finished == false;
            // liquidityX has been set
            retState.finalPt = currentState.currentPoint;
            retState.sqrtFinalPrice_96 = currentState.sqrtPrice_96;
        }
        return retState;
    }
    SwapMathX2Y.x2YRange = x2YRange;
})(SwapMathX2Y = exports.SwapMathX2Y || (exports.SwapMathX2Y = {}));
