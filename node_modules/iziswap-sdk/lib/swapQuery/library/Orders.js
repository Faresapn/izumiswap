"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Orders = void 0;
const BinarySearch_1 = require("./BinarySearch");
const consts_1 = require("./consts");
var Orders;
(function (Orders) {
    function findLeftCursor(orders, currentPoint) {
        const liquidityIdx = BinarySearch_1.BinarySearch.findLeft(orders.liquidityDeltaPoint, currentPoint, BinarySearch_1.BinarySearch.FindLeftOperator.LESS_THAN_OR_EQUAL);
        const sellingIdx = BinarySearch_1.BinarySearch.findLeft(orders.sellingYPoint, currentPoint, BinarySearch_1.BinarySearch.FindLeftOperator.LESS_THAN_OR_EQUAL);
        const isLiquidityPoint = (liquidityIdx >= 0) && (orders.liquidityDeltaPoint[liquidityIdx] === currentPoint);
        const isLimitOrderPoint = (sellingIdx >= 0) && (orders.sellingYPoint[sellingIdx] === currentPoint);
        return { liquidityIdx, sellingIdx, currentPoint, isLimitOrderPoint, isLiquidityPoint };
    }
    Orders.findLeftCursor = findLeftCursor;
    function findRightCursor(orders, currentPoint) {
        const liquidityIdx = BinarySearch_1.BinarySearch.findLeft(orders.liquidityDeltaPoint, currentPoint, BinarySearch_1.BinarySearch.FindLeftOperator.LESS_THAN_OR_EQUAL);
        const sellingIdx = BinarySearch_1.BinarySearch.findRight(orders.sellingXPoint, currentPoint, BinarySearch_1.BinarySearch.FindRightOperator.GREATER_THAN_OR_EQUAL);
        const liquidityLength = orders.liquidityDeltaPoint.length;
        const isLiquidityPoint = (liquidityIdx < liquidityLength) && (orders.liquidityDeltaPoint[liquidityIdx] === currentPoint);
        const sellingLength = orders.sellingXPoint.length;
        const isLimitOrderPoint = (sellingIdx < sellingLength) && (orders.sellingXPoint[sellingIdx] === currentPoint);
        return { liquidityIdx, sellingIdx, currentPoint, isLimitOrderPoint, isLiquidityPoint };
    }
    Orders.findRightCursor = findRightCursor;
    function findLeftFromCursor(orders, currentCursor, currentPoint) {
        let liquidityIdx = currentCursor.liquidityIdx;
        while (liquidityIdx >= 0 && orders.liquidityDeltaPoint[liquidityIdx] > currentPoint) {
            --liquidityIdx;
        }
        let sellingIdx = currentCursor.sellingIdx;
        while (sellingIdx >= 0 && orders.sellingYPoint[sellingIdx] > currentPoint) {
            --sellingIdx;
        }
        const isLiquidityPoint = (liquidityIdx >= 0) && (orders.liquidityDeltaPoint[liquidityIdx] === currentPoint);
        const isLimitOrderPoint = (sellingIdx >= 0) && (orders.sellingYPoint[sellingIdx] === currentPoint);
        return { liquidityIdx, sellingIdx, currentPoint, isLimitOrderPoint, isLiquidityPoint };
    }
    Orders.findLeftFromCursor = findLeftFromCursor;
    function findRightFromCursor(orders, currentCursor, currentPoint) {
        let liquidityIdx = currentCursor.liquidityIdx;
        const liquidityLength = orders.liquidity.length;
        while (liquidityIdx < liquidityLength && orders.liquidityDeltaPoint[liquidityIdx] <= currentPoint) {
            ++liquidityIdx;
        }
        liquidityIdx--;
        let sellingIdx = currentCursor.sellingIdx;
        const sellingLength = orders.sellingX.length;
        while (sellingIdx < sellingLength && orders.sellingXPoint[sellingIdx] < currentPoint) {
            ++sellingIdx;
        }
        const isLiquidityPoint = (liquidityIdx >= 0) && (orders.liquidityDeltaPoint[liquidityIdx] === currentPoint);
        const isLimitOrderPoint = (sellingIdx < sellingLength) && (orders.sellingXPoint[sellingIdx] === currentPoint);
        return { liquidityIdx, sellingIdx, currentPoint, isLimitOrderPoint, isLiquidityPoint };
    }
    Orders.findRightFromCursor = findRightFromCursor;
    function coverLowPoint(orders, lowPt) {
        return (orders.liquidityDeltaPoint[0] <= lowPt && orders.sellingYPoint[0] <= lowPt);
    }
    Orders.coverLowPoint = coverLowPoint;
    function coverHighPoint(orders, highPt) {
        const liquidityNum = orders.liquidityDeltaPoint.length;
        const sellingNum = orders.sellingXPoint.length;
        return (highPt <= orders.liquidityDeltaPoint[liquidityNum - 1] && highPt <= orders.sellingXPoint[sellingNum - 1]);
    }
    Orders.coverHighPoint = coverHighPoint;
    function coverCurrentPoint(orders, currentPt) {
        if (currentPt < orders.liquidityDeltaPoint[0]) {
            return false;
        }
        const liquidityNum = orders.liquidityDeltaPoint.length;
        if (currentPt > orders.liquidityDeltaPoint[liquidityNum - 1]) {
            return false;
        }
        return true;
    }
    Orders.coverCurrentPoint = coverCurrentPoint;
    function nearestLeftOneOrBoundary(orders, currentCursor, point, pointDelta) {
        const liquidityPoint = currentCursor.liquidityIdx >= 0 ? orders.liquidityDeltaPoint[currentCursor.liquidityIdx] : consts_1.Consts.LEFT_MOST_PT;
        const sellingPoint = currentCursor.sellingIdx >= 0 ? orders.sellingYPoint[currentCursor.sellingIdx] : consts_1.Consts.LEFT_MOST_PT;
        const nextPoint = Math.max(liquidityPoint, sellingPoint);
        let mapPt = Math.floor(point / pointDelta);
        const bitIdx = (mapPt % 256 + 256) % 256;
        const leftPtInBlock = (mapPt - bitIdx) * pointDelta;
        return Math.max(nextPoint, leftPtInBlock);
    }
    Orders.nearestLeftOneOrBoundary = nearestLeftOneOrBoundary;
    function nearestRightOneOrBoundary(orders, currentCursor, point, pointDelta) {
        const liquidityLength = orders.liquidity.length;
        const destLiquidityIdx = currentCursor.liquidityIdx + 1;
        const liquidityPoint = destLiquidityIdx < liquidityLength ? orders.liquidityDeltaPoint[destLiquidityIdx] : consts_1.Consts.RIGHT_MOST_PT;
        const destSellingIdx = currentCursor.isLimitOrderPoint ? currentCursor.sellingIdx + 1 : currentCursor.sellingIdx;
        const sellingPoint = destSellingIdx < orders.sellingX.length ? orders.sellingXPoint[destSellingIdx] : consts_1.Consts.RIGHT_MOST_PT;
        const nextPoint = Math.min(liquidityPoint, sellingPoint);
        let mapPt = Math.floor(point / pointDelta);
        // strict right of current point
        mapPt += 1;
        const bitIdx = (mapPt % 256 + 256) % 256;
        const rightPtInBlock = (mapPt + 255 - bitIdx) * pointDelta;
        return Math.min(nextPoint, rightPtInBlock);
    }
    Orders.nearestRightOneOrBoundary = nearestRightOneOrBoundary;
})(Orders = exports.Orders || (exports.Orders = {}));
