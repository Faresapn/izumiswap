"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SwapMathY2X = void 0;
const jsbi_1 = __importDefault(require("jsbi"));
const AmountMath_1 = require("./AmountMath");
const consts_1 = require("./consts");
const LogPowMath_1 = require("./LogPowMath");
const MaxMinMath_1 = require("./MaxMinMath");
const MulDivMath_1 = require("./MulDivMath");
var SwapMathY2X;
(function (SwapMathY2X) {
    function y2XAtPrice(amountY, sqrtPrice_96, currX) {
        let l = MulDivMath_1.MulDivMath.mulDivFloor(amountY, consts_1.Consts.Q96, sqrtPrice_96);
        const acquireX = MaxMinMath_1.MaxMinMath.min(MulDivMath_1.MulDivMath.mulDivFloor(l, consts_1.Consts.Q96, sqrtPrice_96), currX);
        l = MulDivMath_1.MulDivMath.mulDivCeil(acquireX, sqrtPrice_96, consts_1.Consts.Q96);
        const costY = MulDivMath_1.MulDivMath.mulDivCeil(l, sqrtPrice_96, consts_1.Consts.Q96);
        return { costY, acquireX };
    }
    SwapMathY2X.y2XAtPrice = y2XAtPrice;
    function y2XAtPriceLiquidity(amountY, sqrtPrice_96, liquidityX) {
        const maxTransformLiquidityY = MulDivMath_1.MulDivMath.mulDivFloor(amountY, consts_1.Consts.Q96, sqrtPrice_96);
        const transformLiquidityY = MaxMinMath_1.MaxMinMath.min(maxTransformLiquidityY, liquidityX);
        const costY = MulDivMath_1.MulDivMath.mulDivCeil(transformLiquidityY, sqrtPrice_96, consts_1.Consts.Q96);
        const acquireX = MulDivMath_1.MulDivMath.mulDivFloor(transformLiquidityY, consts_1.Consts.Q96, sqrtPrice_96);
        const newLiquidityX = jsbi_1.default.subtract(liquidityX, transformLiquidityY);
        return { costY, acquireX, newLiquidityX };
    }
    SwapMathY2X.y2XAtPriceLiquidity = y2XAtPriceLiquidity;
    function y2XRangeComplete(rg, amountY) {
        const ret = {};
        const maxY = AmountMath_1.AmountMath._getAmountY(rg.liquidity, rg.sqrtPriceL_96, rg.sqrtPriceR_96, rg.sqrtRate_96, true);
        if (jsbi_1.default.lessThanOrEqual(maxY, amountY)) {
            ret.costY = maxY;
            ret.acquireX = AmountMath_1.AmountMath._getAmountX(rg.liquidity, rg.leftPt, rg.rightPt, rg.sqrtPriceR_96, rg.sqrtRate_96, false);
            ret.completeLiquidity = true;
        }
        else {
            const sqrtLoc_96 = jsbi_1.default.add(MulDivMath_1.MulDivMath.mulDivFloor(amountY, jsbi_1.default.subtract(rg.sqrtRate_96, consts_1.Consts.Q96), rg.liquidity), rg.sqrtPriceL_96);
            ret.locPt = LogPowMath_1.LogPowMath.getLogSqrtPriceFloor(sqrtLoc_96);
            ret.locPt = Math.max(rg.leftPt, ret.locPt);
            ret.locPt = Math.min(rg.rightPt - 1, ret.locPt);
            ret.completeLiquidity = false;
            ret.sqrtLoc_96 = LogPowMath_1.LogPowMath.getSqrtPrice(ret.locPt);
            if (ret.locPt === rg.leftPt) {
                ret.costY = consts_1.Consts.ZERO;
                ret.acquireX = consts_1.Consts.ZERO;
                return ret;
            }
            const costY256 = AmountMath_1.AmountMath._getAmountY(rg.liquidity, rg.sqrtPriceL_96, ret.sqrtLoc_96, rg.sqrtRate_96, true);
            // ret.costY <= amountY <= uint128.max
            ret.costY = MaxMinMath_1.MaxMinMath.min(costY256, amountY);
            // costY <= amountY even if the costY is the upperbound of the result
            // because amountY is not a real and sqrtLoc_96 <= sqrtLoc256_96
            ret.acquireX = AmountMath_1.AmountMath._getAmountX(rg.liquidity, rg.leftPt, ret.locPt, ret.sqrtLoc_96, rg.sqrtRate_96, false);
        }
        return ret;
    }
    function y2XRange(currentState, rightPt, sqrtRate_96, originAmountY) {
        const retState = {};
        retState.costY = consts_1.Consts.ZERO;
        retState.acquireX = consts_1.Consts.ZERO;
        retState.finished = false;
        let amountY = originAmountY;
        // first, if current point is not all x, we can not move right directly
        const startHasY = jsbi_1.default.lessThan(currentState.liquidityX, currentState.liquidity);
        if (startHasY) {
            const { costY, acquireX, newLiquidityX } = y2XAtPriceLiquidity(amountY, currentState.sqrtPrice_96, currentState.liquidityX);
            retState.costY = costY;
            retState.acquireX = acquireX;
            retState.liquidityX = newLiquidityX;
            if (jsbi_1.default.greaterThan(retState.liquidityX, consts_1.Consts.ZERO) || jsbi_1.default.greaterThanOrEqual(retState.costY, amountY)) {
                // it means remaining y is not enough to rise current price to price*1.0001
                // but y may remain, so we cannot simply use (costY == amountY)
                retState.finished = true;
                retState.finalPt = currentState.currentPoint;
                retState.sqrtFinalPrice_96 = currentState.sqrtPrice_96;
                return retState;
            }
            else {
                // y not run out
                // not finsihed
                amountY = jsbi_1.default.subtract(amountY, retState.costY);
                currentState.currentPoint += 1;
                if (currentState.currentPoint === rightPt) {
                    retState.finalPt = currentState.currentPoint;
                    // get fixed sqrt price to reduce accumulated error
                    retState.sqrtFinalPrice_96 = LogPowMath_1.LogPowMath.getSqrtPrice(rightPt);
                    return retState;
                }
                // sqrt(price) + sqrt(price) * (1.0001 - 1) == sqrt(price) * 1.0001
                currentState.sqrtPrice_96 = jsbi_1.default.add(currentState.sqrtPrice_96, MulDivMath_1.MulDivMath.mulDivFloor(currentState.sqrtPrice_96, jsbi_1.default.subtract(sqrtRate_96, consts_1.Consts.Q96), consts_1.Consts.Q96));
            }
        }
        const sqrtPriceR_96 = LogPowMath_1.LogPowMath.getSqrtPrice(rightPt);
        // (uint128 liquidCostY, uint256 liquidAcquireX, bool liquidComplete, int24 locPt, uint160 sqrtLoc_96)
        const ret = y2XRangeComplete({
            liquidity: currentState.liquidity,
            sqrtPriceL_96: currentState.sqrtPrice_96,
            leftPt: currentState.currentPoint,
            sqrtPriceR_96: sqrtPriceR_96,
            rightPt: rightPt,
            sqrtRate_96: sqrtRate_96
        }, amountY);
        retState.costY = jsbi_1.default.add(retState.costY, ret.costY);
        amountY = jsbi_1.default.subtract(amountY, ret.costY);
        retState.acquireX = jsbi_1.default.add(retState.acquireX, ret.acquireX);
        if (ret.completeLiquidity) {
            retState.finished = jsbi_1.default.equal(amountY, consts_1.Consts.ZERO);
            retState.finalPt = rightPt;
            retState.sqrtFinalPrice_96 = sqrtPriceR_96;
        }
        else {
            // trade at locPt
            const { costY: locCostY, acquireX: locAcquireX, newLiquidityX } = y2XAtPriceLiquidity(amountY, ret.sqrtLoc_96, currentState.liquidity);
            retState.liquidityX = newLiquidityX;
            retState.costY = jsbi_1.default.add(retState.costY, locCostY);
            retState.acquireX = jsbi_1.default.add(retState.acquireX, locAcquireX);
            retState.finished = true;
            retState.sqrtFinalPrice_96 = ret.sqrtLoc_96;
            retState.finalPt = ret.locPt;
        }
        return retState;
    }
    SwapMathY2X.y2XRange = y2XRange;
})(SwapMathY2X = exports.SwapMathY2X || (exports.SwapMathY2X = {}));
