"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SwapY2XModule = void 0;
const jsbi_1 = __importDefault(require("jsbi"));
const error_1 = require("./error");
const consts_1 = require("./library/consts");
const LogPowMath_1 = require("./library/LogPowMath");
const MulDivMath_1 = require("./library/MulDivMath");
const Orders_1 = require("./library/Orders");
const SwapMathY2X_1 = require("./library/SwapMathY2X");
const SwapMathY2XDesire_1 = require("./library/SwapMathY2XDesire");
var SwapY2XModule;
(function (SwapY2XModule) {
    function swapY2X(pool, amount, highPt) {
        (0, error_1.swapQueryInvariant)(jsbi_1.default.greaterThan(amount, consts_1.Consts.ZERO), error_1.SwapQueryErrCode.AMOUNT_ZERO_ERROR);
        highPt = Math.min(highPt, pool.rightMostPt);
        (0, error_1.swapQueryInvariant)(Orders_1.Orders.coverHighPoint(pool.orders, highPt), error_1.SwapQueryErrCode.HIGHPT_OVER_ORDER_RANGE_ERROR);
        let amountX = consts_1.Consts.ZERO;
        let amountY = consts_1.Consts.ZERO;
        const st = pool.state;
        (0, error_1.swapQueryInvariant)(highPt > st.currentPoint, error_1.SwapQueryErrCode.HIGHPT_NOT_GREATER_THAN_CURRENTPT_ERROR);
        (0, error_1.swapQueryInvariant)(Orders_1.Orders.coverCurrentPoint(pool.orders, st.currentPoint), error_1.SwapQueryErrCode.CURRENTPT_OVER_ORDER_RANGE_ERROR);
        let finished = false;
        const sqrtRate_96 = pool.sqrtRate_96;
        const pointDelta = pool.pointDelta;
        let currentCursor = Orders_1.Orders.findRightCursor(pool.orders, st.currentPoint);
        const fee = jsbi_1.default.BigInt(pool.fee);
        const feeRemain = jsbi_1.default.BigInt(1e6 - pool.fee);
        while (st.currentPoint < highPt && !finished) {
            if (currentCursor.isLimitOrderPoint) {
                const amountNoFee = MulDivMath_1.MulDivMath.mulDivFloor(amount, feeRemain, consts_1.Consts.ONE_M);
                if (jsbi_1.default.greaterThan(amountNoFee, consts_1.Consts.ZERO)) {
                    const currX = pool.orders.sellingX[currentCursor.sellingIdx];
                    const { costY, acquireX } = SwapMathY2X_1.SwapMathY2X.y2XAtPrice(amountNoFee, st.sqrtPrice_96, currX);
                    if (jsbi_1.default.lessThan(acquireX, currX) || jsbi_1.default.greaterThanOrEqual(costY, amountNoFee)) {
                        finished = true;
                    }
                    let feeAmount = consts_1.Consts.ZERO;
                    if (jsbi_1.default.greaterThanOrEqual(costY, amountNoFee)) {
                        feeAmount = jsbi_1.default.subtract(amount, costY);
                    }
                    else {
                        feeAmount = MulDivMath_1.MulDivMath.mulDivCeil(costY, fee, feeRemain);
                    }
                    const cost = jsbi_1.default.add(costY, feeAmount);
                    amount = jsbi_1.default.subtract(amount, cost);
                    amountY = jsbi_1.default.add(amountY, cost);
                    amountX = jsbi_1.default.add(amountX, acquireX);
                }
                else {
                    finished = true;
                }
            }
            if (finished) {
                break;
            }
            const nextPoint = Math.min(Orders_1.Orders.nearestRightOneOrBoundary(pool.orders, currentCursor, st.currentPoint, pointDelta), highPt);
            if (jsbi_1.default.equal(st.liquidity, consts_1.Consts.ZERO)) {
                st.currentPoint = nextPoint;
                st.sqrtPrice_96 = LogPowMath_1.LogPowMath.getSqrtPrice(st.currentPoint);
                currentCursor = Orders_1.Orders.findRightFromCursor(pool.orders, currentCursor, st.currentPoint);
                st.liquidity = pool.orders.liquidity[currentCursor.liquidityIdx];
                st.liquidityX = st.liquidity;
            }
            else {
                const amountNoFee = MulDivMath_1.MulDivMath.mulDivFloor(amount, feeRemain, consts_1.Consts.ONE_M);
                if (jsbi_1.default.greaterThan(amountNoFee, consts_1.Consts.ZERO)) {
                    const retState = SwapMathY2X_1.SwapMathY2X.y2XRange(st, nextPoint, sqrtRate_96, amountNoFee);
                    finished = retState.finished;
                    let feeAmount = consts_1.Consts.ZERO;
                    if (jsbi_1.default.greaterThanOrEqual(retState.costY, amountNoFee)) {
                        feeAmount = jsbi_1.default.subtract(amount, retState.costY);
                    }
                    else {
                        feeAmount = MulDivMath_1.MulDivMath.mulDivCeil(retState.costY, fee, feeRemain);
                    }
                    const cost = jsbi_1.default.add(retState.costY, feeAmount);
                    amountX = jsbi_1.default.add(amountX, retState.acquireX);
                    amountY = jsbi_1.default.add(amountY, cost);
                    amount = jsbi_1.default.subtract(amount, cost);
                    st.currentPoint = retState.finalPt;
                    st.sqrtPrice_96 = retState.sqrtFinalPrice_96;
                    st.liquidityX = retState.liquidityX;
                }
                else {
                    finished = true;
                }
                if (st.currentPoint === nextPoint) {
                    currentCursor = Orders_1.Orders.findRightFromCursor(pool.orders, currentCursor, st.currentPoint);
                    st.liquidity = pool.orders.liquidity[currentCursor.liquidityIdx];
                    st.liquidityX = st.liquidity;
                }
                else {
                    // not necessary, because retState.finished must be true
                    finished = true;
                }
            }
        }
        return { amountX, amountY };
    }
    SwapY2XModule.swapY2X = swapY2X;
    function swapY2XDesireX(pool, desireX, highPt) {
        (0, error_1.swapQueryInvariant)(jsbi_1.default.greaterThan(desireX, consts_1.Consts.ZERO), error_1.SwapQueryErrCode.AMOUNT_ZERO_ERROR);
        highPt = Math.min(highPt, pool.rightMostPt);
        (0, error_1.swapQueryInvariant)(Orders_1.Orders.coverHighPoint(pool.orders, highPt), error_1.SwapQueryErrCode.HIGHPT_OVER_ORDER_RANGE_ERROR);
        let amountX = consts_1.Consts.ZERO;
        let amountY = consts_1.Consts.ZERO;
        const st = pool.state;
        (0, error_1.swapQueryInvariant)(highPt > st.currentPoint, error_1.SwapQueryErrCode.HIGHPT_NOT_GREATER_THAN_CURRENTPT_ERROR);
        (0, error_1.swapQueryInvariant)(Orders_1.Orders.coverCurrentPoint(pool.orders, st.currentPoint), error_1.SwapQueryErrCode.CURRENTPT_OVER_ORDER_RANGE_ERROR);
        let finished = false;
        const sqrtRate_96 = pool.sqrtRate_96;
        const pointDelta = pool.pointDelta;
        let currentCursor = Orders_1.Orders.findRightCursor(pool.orders, st.currentPoint);
        const fee = jsbi_1.default.BigInt(pool.fee);
        const feeRemain = jsbi_1.default.BigInt(1e6 - pool.fee);
        while (st.currentPoint < highPt && !finished) {
            if (currentCursor.isLimitOrderPoint) {
                const currX = pool.orders.sellingX[currentCursor.sellingIdx];
                const { costY, acquireX } = SwapMathY2XDesire_1.SwapMathY2XDesire.y2XAtPrice(desireX, st.sqrtPrice_96, currX);
                if (jsbi_1.default.greaterThanOrEqual(acquireX, desireX)) {
                    finished = true;
                }
                const feeAmount = MulDivMath_1.MulDivMath.mulDivCeil(costY, fee, feeRemain);
                const cost = jsbi_1.default.add(costY, feeAmount);
                desireX = jsbi_1.default.subtract(desireX, acquireX);
                amountY = jsbi_1.default.add(amountY, cost);
                amountX = jsbi_1.default.add(amountX, acquireX);
            }
            if (finished) {
                break;
            }
            const nextPoint = Math.min(Orders_1.Orders.nearestRightOneOrBoundary(pool.orders, currentCursor, st.currentPoint, pointDelta), highPt);
            if (jsbi_1.default.equal(st.liquidity, consts_1.Consts.ZERO)) {
                st.currentPoint = nextPoint;
                st.sqrtPrice_96 = LogPowMath_1.LogPowMath.getSqrtPrice(st.currentPoint);
                currentCursor = Orders_1.Orders.findRightFromCursor(pool.orders, currentCursor, st.currentPoint);
                st.liquidity = pool.orders.liquidity[currentCursor.liquidityIdx];
                st.liquidityX = st.liquidity;
            }
            else {
                const retState = SwapMathY2XDesire_1.SwapMathY2XDesire.y2XRange(st, nextPoint, sqrtRate_96, desireX);
                finished = retState.finished;
                const feeAmount = MulDivMath_1.MulDivMath.mulDivCeil(retState.costY, fee, feeRemain);
                const cost = jsbi_1.default.add(retState.costY, feeAmount);
                amountX = jsbi_1.default.add(amountX, retState.acquireX);
                amountY = jsbi_1.default.add(amountY, cost);
                desireX = jsbi_1.default.subtract(desireX, retState.acquireX);
                st.currentPoint = retState.finalPt;
                st.sqrtPrice_96 = retState.sqrtFinalPrice_96;
                st.liquidityX = retState.liquidityX;
                if (st.currentPoint === nextPoint) {
                    currentCursor = Orders_1.Orders.findRightFromCursor(pool.orders, currentCursor, st.currentPoint);
                    st.liquidity = pool.orders.liquidity[currentCursor.liquidityIdx];
                    st.liquidityX = st.liquidity;
                }
                else {
                    // not necessary, because retState.finished must be true
                    finished = true;
                }
            }
        }
        return { amountX, amountY };
    }
    SwapY2XModule.swapY2XDesireX = swapY2XDesireX;
})(SwapY2XModule = exports.SwapY2XModule || (exports.SwapY2XModule = {}));
