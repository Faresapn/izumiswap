"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSwapChainWithExactInputCall = exports.getDecLiquidityAndCollectCall = exports.getCollectCall = exports.getAddLiquidityCall = exports.getMintCall = exports.getBoxContract = void 0;
const base_1 = require("../base");
const abi_json_1 = __importDefault(require("./abi.json"));
const getBoxContract = (address, web3) => {
    return (0, base_1.getEVMContract)(abi_json_1.default, address, web3);
};
exports.getBoxContract = getBoxContract;
const getMintCall = (boxContract, account, chain, params, gasPrice) => {
    var _a, _b;
    const deadline = (_a = params.deadline) !== null && _a !== void 0 ? _a : '0xffffffff';
    const ifReverse = (0, base_1.getSwapTokenAddress)(params.tokenA).toLowerCase() > (0, base_1.getSwapTokenAddress)(params.tokenB).toLowerCase();
    const options = {
        from: account,
        value: '0',
        maxFeePerGas: gasPrice,
    };
    if (chain.tokenSymbol === params.tokenA.symbol) {
        options.value = params.maxAmountA;
    }
    if (chain.tokenSymbol === params.tokenB.symbol) {
        options.value = params.maxAmountB;
    }
    const recipientAddress = (_b = params.recipient) !== null && _b !== void 0 ? _b : account;
    let mintCalling = undefined;
    if (ifReverse) {
        const tokenXIsWrap = !params.tokenB.wrapTokenAddress ? false : true;
        const tokenYIsWrap = !params.tokenA.wrapTokenAddress ? false : true;
        mintCalling = boxContract.methods.mint({
            miner: recipientAddress,
            tokenX: (0, base_1.getSwapTokenAddress)(params.tokenB),
            tokenY: (0, base_1.getSwapTokenAddress)(params.tokenA),
            fee: params.fee,
            pl: params.leftPoint,
            pr: params.rightPoint,
            xLim: params.maxAmountB,
            yLim: params.maxAmountA,
            amountXMin: params.minAmountB,
            amountYMin: params.minAmountA,
            deadline
        }, tokenXIsWrap, tokenYIsWrap);
    }
    else {
        const tokenXIsWrap = !params.tokenA.wrapTokenAddress ? false : true;
        const tokenYIsWrap = !params.tokenB.wrapTokenAddress ? false : true;
        mintCalling = boxContract.methods.mint({
            miner: recipientAddress,
            tokenX: (0, base_1.getSwapTokenAddress)(params.tokenA),
            tokenY: (0, base_1.getSwapTokenAddress)(params.tokenB),
            fee: params.fee,
            pl: params.leftPoint,
            pr: params.rightPoint,
            xLim: params.maxAmountA,
            yLim: params.maxAmountB,
            amountXMin: params.minAmountA,
            amountYMin: params.minAmountB,
            deadline
        }, tokenXIsWrap, tokenYIsWrap);
    }
    return { mintCalling, options: (0, base_1.buildSendingParams)(chain, options, gasPrice) };
};
exports.getMintCall = getMintCall;
const getAddLiquidityCall = (boxContract, account, chain, params, gasPrice) => {
    var _a;
    const options = {
        from: account,
        value: '0',
        maxFeePerGas: gasPrice,
    };
    if (chain.tokenSymbol === params.tokenA.symbol) {
        options.value = params.maxAmountA;
    }
    if (chain.tokenSymbol === params.tokenB.symbol) {
        options.value = params.maxAmountB;
    }
    const ifReverse = (0, base_1.getSwapTokenAddress)(params.tokenA).toLowerCase() > (0, base_1.getSwapTokenAddress)(params.tokenB).toLowerCase();
    const deadline = (_a = params.deadline) !== null && _a !== void 0 ? _a : '0xffffffff';
    let addLiquidityCalling = undefined;
    if (ifReverse) {
        const tokenXIsWrap = !params.tokenB.wrapTokenAddress ? false : true;
        const tokenYIsWrap = !params.tokenA.wrapTokenAddress ? false : true;
        addLiquidityCalling = boxContract.methods.addLiquidity({
            lid: params.tokenId,
            xLim: params.maxAmountB,
            yLim: params.maxAmountA,
            amountXMin: params.minAmountB,
            amountYMin: params.minAmountA,
            deadline
        }, (0, base_1.getSwapTokenAddress)(params.tokenB), (0, base_1.getSwapTokenAddress)(params.tokenA), tokenXIsWrap, tokenYIsWrap);
    }
    else {
        const tokenXIsWrap = !params.tokenA.wrapTokenAddress ? false : true;
        const tokenYIsWrap = !params.tokenB.wrapTokenAddress ? false : true;
        addLiquidityCalling = boxContract.methods.addLiquidity({
            lid: params.tokenId,
            xLim: params.maxAmountA,
            yLim: params.maxAmountB,
            amountXMin: params.minAmountA,
            amountYMin: params.minAmountB,
            deadline
        }, (0, base_1.getSwapTokenAddress)(params.tokenA), (0, base_1.getSwapTokenAddress)(params.tokenB), tokenXIsWrap, tokenYIsWrap);
    }
    return { addLiquidityCalling, options: (0, base_1.buildSendingParams)(chain, options, gasPrice) };
};
exports.getAddLiquidityCall = getAddLiquidityCall;
const getCollectCall = (boxContract, account, chain, params, gasPrice) => {
    var _a;
    const options = {
        from: account,
        value: '0',
        maxFeePerGas: gasPrice,
    };
    const ifReverse = (0, base_1.getSwapTokenAddress)(params.tokenA).toLowerCase() > (0, base_1.getSwapTokenAddress)(params.tokenB).toLowerCase();
    const recipientAddress = (_a = params.recipient) !== null && _a !== void 0 ? _a : account;
    let collectCalling = undefined;
    if (ifReverse) {
        const tokenXIsWrap = !params.tokenB.wrapTokenAddress ? false : true;
        const tokenYIsWrap = !params.tokenA.wrapTokenAddress ? false : true;
        collectCalling = boxContract.methods.collect(recipientAddress, params.tokenId, params.maxAmountB, params.maxAmountA, (0, base_1.getSwapTokenAddress)(params.tokenB), (0, base_1.getSwapTokenAddress)(params.tokenA), tokenXIsWrap, tokenYIsWrap);
    }
    else {
        const tokenXIsWrap = !params.tokenA.wrapTokenAddress ? false : true;
        const tokenYIsWrap = !params.tokenB.wrapTokenAddress ? false : true;
        collectCalling = boxContract.methods.collect(recipientAddress, params.tokenId, params.maxAmountA, params.maxAmountB, (0, base_1.getSwapTokenAddress)(params.tokenA), (0, base_1.getSwapTokenAddress)(params.tokenB), tokenXIsWrap, tokenYIsWrap);
    }
    return { collectCalling, options: (0, base_1.buildSendingParams)(chain, options, gasPrice) };
};
exports.getCollectCall = getCollectCall;
const getDecLiquidityAndCollectCall = (boxContract, account, chain, params, gasPrice) => {
    var _a, _b;
    const options = {
        from: account,
        value: '0',
        maxFeePerGas: gasPrice,
    };
    const ifReverse = (0, base_1.getSwapTokenAddress)(params.tokenA).toLowerCase() > (0, base_1.getSwapTokenAddress)(params.tokenB).toLowerCase();
    const deadline = (_a = params.deadline) !== null && _a !== void 0 ? _a : '0xffffffff';
    const recipientAddress = (_b = params.recipient) !== null && _b !== void 0 ? _b : account;
    let calling = undefined;
    if (ifReverse) {
        const tokenXIsWrap = !params.tokenB.wrapTokenAddress ? false : true;
        const tokenYIsWrap = !params.tokenA.wrapTokenAddress ? false : true;
        calling = boxContract.methods.decreaseLiquidity(recipientAddress, params.tokenId, params.liquidDelta, params.minAmountB, params.minAmountA, deadline, (0, base_1.getSwapTokenAddress)(params.tokenB), (0, base_1.getSwapTokenAddress)(params.tokenA), tokenXIsWrap, tokenYIsWrap);
    }
    else {
        const tokenXIsWrap = !params.tokenA.wrapTokenAddress ? false : true;
        const tokenYIsWrap = !params.tokenB.wrapTokenAddress ? false : true;
        calling = boxContract.methods.decreaseLiquidity(recipientAddress, params.tokenId, params.liquidDelta, params.minAmountA, params.minAmountB, deadline, (0, base_1.getSwapTokenAddress)(params.tokenA), (0, base_1.getSwapTokenAddress)(params.tokenB), tokenXIsWrap, tokenYIsWrap);
    }
    return { calling, options: (0, base_1.buildSendingParams)(chain, options, gasPrice) };
};
exports.getDecLiquidityAndCollectCall = getDecLiquidityAndCollectCall;
const getSwapChainWithExactInputCall = (boxContract, account, chain, params, gasPrice) => {
    var _a, _b;
    const deadline = (_a = params.deadline) !== null && _a !== void 0 ? _a : '0xffffffff';
    const options = {
        from: account,
        value: '0',
        maxFeePerGas: gasPrice,
    };
    const path = (0, base_1.getTokenChainPath)(params.tokenChain, params.feeChain);
    const recipient = (_b = params.recipient) !== null && _b !== void 0 ? _b : account;
    if (chain.tokenSymbol === params.tokenChain[0].symbol) {
        options.value = params.inputAmount;
    }
    const firstIsWrap = !params.tokenChain[0].wrapTokenAddress ? false : true;
    const lastIsWrap = !params.tokenChain[params.tokenChain.length - 1].wrapTokenAddress ? false : true;
    const swapCalling = boxContract.methods.swapAmount({
        path,
        recipient,
        amount: params.inputAmount,
        minAcquired: params.minOutputAmount,
        deadline
    }, firstIsWrap, lastIsWrap);
    return { swapCalling, options: (0, base_1.buildSendingParams)(chain, options, gasPrice) };
};
exports.getSwapChainWithExactInputCall = getSwapChainWithExactInputCall;
