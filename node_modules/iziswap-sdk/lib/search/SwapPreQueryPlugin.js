"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SwapPreQueryPlugin = void 0;
const address_1 = require("@ethersproject/address");
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const base_1 = require("../base");
const types_1 = require("./types");
const liquidityManager_1 = require("../liquidityManager");
const pool_1 = require("../pool");
const stateParams = [
    {
        "internalType": "uint160",
        "name": "sqrtPrice_96",
        "type": "uint160"
    },
    {
        "internalType": "int24",
        "name": "currentPoint",
        "type": "int24"
    },
    {
        "internalType": "uint16",
        "name": "observationCurrentIndex",
        "type": "uint16"
    },
    {
        "internalType": "uint16",
        "name": "observationQueueLen",
        "type": "uint16"
    },
    {
        "internalType": "uint16",
        "name": "observationNextQueueLen",
        "type": "uint16"
    },
    {
        "internalType": "bool",
        "name": "locked",
        "type": "bool"
    },
    {
        "internalType": "uint128",
        "name": "liquidity",
        "type": "uint128"
    },
    {
        "internalType": "uint128",
        "name": "liquidityX",
        "type": "uint128"
    }
];
class SwapPreQueryPlugin {
    constructor(preQueryResult, liquidityManagerAddress, chainId, web3) {
        this.pairsOfCalling = undefined;
        this.knownPairs = undefined;
        this.knownPoolAddress = undefined;
        this.knownPoolPoint = undefined;
        this.unknownPoolPoint = undefined;
        this.allLinks = undefined;
        this.dagNodes = undefined;
        this.responsePoolAddress = undefined;
        this.tokenA = undefined;
        this.tokenB = undefined;
        this.web3 = web3;
        if (preQueryResult.lastChainId === chainId) {
            this.preQueryResult = Object.assign({}, preQueryResult);
        }
        else {
            this.preQueryResult = (0, types_1.initiZiPreResult)(chainId);
        }
        this.chainId = chainId;
        this.liquidityManagerAddress = liquidityManagerAddress;
        this.liquidityManagerContract = (0, liquidityManager_1.getLiquidityManagerContract)(this.liquidityManagerAddress, web3);
        this.fakePoolContract = (0, pool_1.getPoolContract)(liquidityManagerAddress, web3);
        this.poolBlackSet = new Set();
        this.support001PoolSet = new Set();
        this.midTokenList = [];
        this.supportFeeContractNumbers = [];
    }
    setPoolBlackList(poolBlackList) {
        this.poolBlackSet.clear();
        for (const pool of poolBlackList) {
            this.poolBlackSet.add(this.getSwapPoolKey(pool.tokenA, pool.tokenB, pool.feeContractNumber));
        }
    }
    setMidTokenList(midTokenList) {
        this.midTokenList = midTokenList;
    }
    setSupportFeeContractNumbers(supportFeeContractNumbers) {
        this.supportFeeContractNumbers = supportFeeContractNumbers;
    }
    setSupport001Pools(support001Pools) {
        this.support001PoolSet.clear();
        for (const pool of support001Pools) {
            this.support001PoolSet.add(this.getSwapPoolKey(pool.tokenA, pool.tokenB, pool.feeContractNumber));
        }
    }
    getSwapPoolKey(tokenA, tokenB, feeContractNumber) {
        const tokenASymbol = tokenA.symbol.toUpperCase();
        const tokenBSymbol = tokenB.symbol.toUpperCase();
        if (tokenASymbol < tokenBSymbol) {
            return tokenASymbol + '-' + tokenBSymbol + '-' + String(feeContractNumber);
        }
        else {
            return tokenBSymbol + '-' + tokenASymbol + '-' + String(feeContractNumber);
        }
    }
    getSwapPoolKeySymbol(tokenASymbol, tokenBSymbol, feeContractNumber) {
        const a = tokenASymbol.toUpperCase();
        const b = tokenBSymbol.toUpperCase();
        if (a < b) {
            return a + '-' + b + '-' + String(feeContractNumber);
        }
        else {
            return b + '-' + a + '-' + String(feeContractNumber);
        }
    }
    hasPool(tokenA, tokenB, feeContractNumber) {
        const lastPreQueryResult = this.preQueryResult;
        if (this.chainId != lastPreQueryResult.lastChainId) {
            return false;
        }
        const key = this.getSwapPoolKey(tokenA, tokenB, feeContractNumber);
        return lastPreQueryResult.pool.has(key);
    }
    blackPool(tokenA, tokenB, feeContractNumber) {
        const poolKey = this.getSwapPoolKey(tokenA, tokenB, feeContractNumber);
        return this.poolBlackSet.has(poolKey);
    }
    getPreQueryDag(tokenA, tokenB) {
        this.tokenA = tokenA;
        this.tokenB = tokenB;
        const tokenBList = [];
        this.midTokenList.forEach((s) => {
            if (s.symbol === tokenA.symbol || s.symbol === tokenB.symbol) {
                return;
            }
            tokenBList.push(s);
        });
        this.allLinks = [];
        for (const tokenB of tokenBList) {
            for (const feeContractNumber of this.supportFeeContractNumbers) {
                this.allLinks.push({
                    tokenB,
                    feeContractNumber
                });
            }
        }
        tokenBList.push(Object.assign({}, tokenA));
        tokenBList.push(Object.assign({}, tokenB));
        this.pairsOfCalling = [];
        this.knownPairs = [];
        const poolCalling = [];
        // pool address calling
        for (let i = 0; i < tokenBList.length; i++) {
            for (let j = i + 1; j < tokenBList.length; j++) {
                for (const feeContractNumber of this.supportFeeContractNumbers) {
                    if (this.blackPool(tokenBList[i], tokenBList[j], feeContractNumber)) {
                        continue;
                    }
                    if (!this.hasPool(tokenBList[i], tokenBList[j], feeContractNumber)) {
                        poolCalling.push(this.liquidityManagerContract.methods.pool((0, base_1.getSwapTokenAddress)(tokenBList[i]), (0, base_1.getSwapTokenAddress)(tokenBList[j]), feeContractNumber).encodeABI());
                        this.pairsOfCalling.push({
                            tokenA: tokenBList[i],
                            tokenB: tokenBList[j],
                            feeContractNumber
                        });
                    }
                    else {
                        this.knownPairs.push({
                            tokenA: tokenBList[i],
                            tokenB: tokenBList[j],
                            feeContractNumber
                        });
                    }
                }
            }
        }
        this.responsePoolAddress = [];
        this.unknownPoolPoint = [];
        for (let i = 0; i < this.pairsOfCalling.length; i++) {
            this.responsePoolAddress.push('');
            this.unknownPoolPoint.push(0);
        }
        const preQueryResult = this.preQueryResult;
        const poolCallingNodes = poolCalling.map((calling, idx) => {
            return {
                calling,
                preIdx: undefined,
                targetAddress: this.liquidityManagerAddress,
                parseCallingResponse: (response) => {
                    const address = this.web3.eth.abi.decodeParameter("address", response);
                    this.responsePoolAddress[idx] = address;
                }
            };
        });
        const knownPairStateCalling = [];
        this.knownPoolPoint = [];
        for (let i = 0; i < this.knownPairs.length; i++) {
            this.knownPoolPoint.push(0);
        }
        // state calling of known pairs
        this.knownPoolAddress = [];
        for (const pair of this.knownPairs) {
            const poolKey = this.getSwapPoolKey(pair.tokenA, pair.tokenB, pair.feeContractNumber);
            const poolAddress = preQueryResult.pool.get(poolKey);
            knownPairStateCalling.push(this.fakePoolContract.methods.state().encodeABI());
            this.knownPoolAddress.push(poolAddress);
        }
        const knownPairStateCallingNodes = knownPairStateCalling.map((calling, idx) => {
            const poolAddress = this.knownPoolAddress[idx];
            return {
                calling,
                preIdx: undefined,
                targetAddress: poolAddress,
                parseCallingResponse: (response) => {
                    const state = this.web3.eth.abi.decodeParameters(stateParams, response);
                    this.knownPoolPoint[idx] = Number(state["currentPoint"]);
                }
            };
        });
        // state calling of unknown pairs
        const unknownPairStateCallingNodes = this.pairsOfCalling.map((poolPair, idx) => {
            return {
                preIdx: [idx],
                getCallingAndTargetAddress: () => {
                    const poolAddress = this.responsePoolAddress[idx];
                    if (!(0, address_1.isAddress)(poolAddress) || new bignumber_js_1.default(poolAddress).eq(0)) {
                        return undefined;
                    }
                    const calling = this.fakePoolContract.methods.state().encodeABI();
                    return { targetAddress: poolAddress, calling };
                },
                parseCallingResponse: (response) => {
                    const state = this.web3.eth.abi.decodeParameters(stateParams, response);
                    this.unknownPoolPoint[idx] = Number(state["currentPoint"]);
                }
            };
        });
        this.dagNodes = [...poolCallingNodes, ...knownPairStateCallingNodes, ...unknownPairStateCallingNodes];
        return this.dagNodes;
    }
    getQueryResult() {
        const lastPreQueryResult = this.preQueryResult;
        const preQueryResult = {
            pathWithFee100: [],
            pathWithOutFee100: [],
            lastChainId: lastPreQueryResult.lastChainId,
            pool: lastPreQueryResult.pool,
            poolPoint: lastPreQueryResult.poolPoint
        };
        if (preQueryResult.lastChainId !== this.chainId) {
            preQueryResult.pool = new Map();
            preQueryResult.poolPoint = new Map();
        }
        else if (preQueryResult.lastChainId === this.chainId && this.dagNodes.length === 0) {
            preQueryResult.pathWithFee100 = lastPreQueryResult.pathWithFee100;
            preQueryResult.pathWithOutFee100 = lastPreQueryResult.pathWithOutFee100;
            // no new prequerys
            return preQueryResult;
        }
        for (let i = 0; i < this.responsePoolAddress.length; i++) {
            if (this.responsePoolAddress[i] === '') {
                continue;
            }
            const poolAddress = this.responsePoolAddress[i];
            if (!(0, address_1.isAddress)(poolAddress) || new bignumber_js_1.default(poolAddress).eq(0)) {
                continue;
            }
            const poolPair = this.pairsOfCalling[i];
            const poolKey = this.getSwapPoolKey(poolPair.tokenA, poolPair.tokenB, poolPair.feeContractNumber);
            preQueryResult.pool.set(poolKey, poolAddress);
            preQueryResult.poolPoint.set(poolKey, this.unknownPoolPoint[i]);
        }
        for (let i = 0; i < this.knownPairs.length; i++) {
            const poolPair = this.knownPairs[i];
            const poolKey = this.getSwapPoolKey(poolPair.tokenA, poolPair.tokenB, poolPair.feeContractNumber);
            preQueryResult.poolPoint.set(poolKey, this.knownPoolPoint[i]);
        }
        const paths = [];
        for (const i in this.allLinks) {
            const firstKey = this.getSwapPoolKey(this.tokenA, this.allLinks[i].tokenB, this.allLinks[i].feeContractNumber);
            if (!preQueryResult.pool.has(firstKey)) {
                continue;
            }
            if (this.poolBlackSet.has(firstKey)) {
                continue;
            }
            for (const j in this.allLinks) {
                const lastKey = this.getSwapPoolKey(this.allLinks[j].tokenB, this.tokenB, this.allLinks[j].feeContractNumber);
                if (!preQueryResult.pool.has(lastKey)) {
                    continue;
                }
                if (this.poolBlackSet.has(lastKey)) {
                    continue;
                }
                if (this.allLinks[i].tokenB.symbol === this.allLinks[j].tokenB.symbol) {
                    const feeAB = this.allLinks[i].feeContractNumber;
                    const feeBC = this.allLinks[j].feeContractNumber;
                    paths.push({
                        tokenChain: [Object.assign({}, this.tokenA), Object.assign({}, this.allLinks[i].tokenB), Object.assign({}, this.tokenB)],
                        feeContractNumber: [feeAB, feeBC]
                    });
                }
                else {
                    for (const middleFeeContractNumber of this.supportFeeContractNumbers) {
                        const middleKey = this.getSwapPoolKey(this.allLinks[i].tokenB, this.allLinks[j].tokenB, middleFeeContractNumber);
                        if (!preQueryResult.pool.has(middleKey)) {
                            continue;
                        }
                        if (this.poolBlackSet.has(middleKey)) {
                            continue;
                        }
                        paths.push({
                            tokenChain: [Object.assign({}, this.tokenA), Object.assign({}, this.allLinks[i].tokenB), Object.assign({}, this.allLinks[j].tokenB), Object.assign({}, this.tokenB)],
                            feeContractNumber: [this.allLinks[i].feeContractNumber, middleFeeContractNumber, this.allLinks[j].feeContractNumber]
                        });
                    }
                }
            }
        }
        for (const feeContractNumber of this.supportFeeContractNumbers) {
            const directKey = this.getSwapPoolKey(this.tokenA, this.tokenB, feeContractNumber);
            if (!preQueryResult.pool.has(directKey)) {
                continue;
            }
            if (this.poolBlackSet.has(directKey)) {
                continue;
            }
            paths.push({
                tokenChain: [Object.assign({}, this.tokenA), Object.assign({}, this.tokenB)],
                feeContractNumber: [feeContractNumber]
            });
        }
        const pathWithoutFee100 = [];
        const pathWithFee100 = [];
        for (const path of paths) {
            let noFee100Pool = true;
            let validFee100Pool = true;
            for (let i = 0; i < path.feeContractNumber.length; i++) {
                const fee = path.feeContractNumber[i];
                if (fee === 100) {
                    noFee100Pool = false;
                    const tokenA = path.tokenChain[i];
                    const tokenB = path.tokenChain[i + 1];
                    const poolKey = this.getSwapPoolKey(tokenA, tokenB, fee);
                    if (!this.support001PoolSet.has(poolKey)) {
                        validFee100Pool = false;
                        break;
                    }
                }
            }
            if (noFee100Pool) {
                pathWithoutFee100.push(path);
            }
            else {
                if (validFee100Pool) {
                    pathWithFee100.push(path);
                }
            }
        }
        preQueryResult.pathWithFee100 = pathWithFee100;
        preQueryResult.pathWithOutFee100 = pathWithoutFee100;
        return preQueryResult;
    }
}
exports.SwapPreQueryPlugin = SwapPreQueryPlugin;
