"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.doPathQuery = exports.doPreQuery = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const types_1 = require("./types");
const SwapPreQueryPlugin_1 = require("./SwapPreQueryPlugin");
const SwapPathQueryPlugin_1 = require("./SwapPathQueryPlugin");
function checkNodeCanVisit(dagNode, visited) {
    if (!dagNode.preIdx) {
        return true;
    }
    const maxIdx = Math.max(...dagNode.preIdx);
    return maxIdx < visited;
}
function checkFinish(dagNodes, visited) {
    if (visited < dagNodes.length) {
        return false;
    }
    return true;
}
function multiQuery(multicall, calling, targetAddress) {
    return __awaiter(this, void 0, void 0, function* () {
        const result = yield multicall.methods.multicall(targetAddress, calling).call();
        return {
            successes: result.successes,
            results: result.results
        };
    });
}
const doPreQuery = (params, preQueryResult) => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    const { chainId, web3, multicall, tokenIn, tokenOut, } = params;
    const preQueryPlugin = new SwapPreQueryPlugin_1.SwapPreQueryPlugin(preQueryResult, params.liquidityManagerAddress, chainId, web3);
    preQueryPlugin.setPoolBlackList(params.poolBlackList);
    preQueryPlugin.setMidTokenList(params.midTokenList);
    preQueryPlugin.setSupportFeeContractNumbers(params.supportFeeContractNumbers);
    preQueryPlugin.setSupport001Pools(params.support001Pools);
    const dagNodes = (_a = preQueryPlugin.getPreQueryDag(tokenIn, tokenOut)) !== null && _a !== void 0 ? _a : [];
    let visited = 0;
    let currentNum = 0;
    while (!checkFinish(dagNodes, visited)) {
        let num = 0;
        while (num + visited < dagNodes.length) {
            if (!checkNodeCanVisit(dagNodes[num + visited], visited)) {
                break;
            }
            else {
                num++;
            }
        }
        currentNum = num;
        const currentNodes = [];
        for (let j = 0; j < currentNum; j++) {
            const currentNode = dagNodes[visited + j];
            if (!currentNode.calling || !currentNode.targetAddress) {
                const query = currentNode.getCallingAndTargetAddress();
                if (query) {
                    currentNode.calling = query.calling;
                    currentNode.targetAddress = query.targetAddress;
                    currentNodes.push(currentNode);
                }
            }
            else {
                currentNodes.push(currentNode);
            }
        }
        const targetAddress = currentNodes.map((n) => n.targetAddress);
        const calling = currentNodes.map((n) => n.calling);
        const { successes, results } = yield multiQuery(multicall, calling, targetAddress);
        for (let i = 0; i < successes.length; i++) {
            if (!successes[i] || results[i] === '0x') {
                continue;
            }
            try {
                currentNodes[i].parseCallingResponse(results[i]);
            }
            catch (_) { }
        }
        visited += currentNum;
    }
    return preQueryPlugin.getQueryResult();
});
exports.doPreQuery = doPreQuery;
function checkNewPathQueryBetter(oldPathQuery, newPathQuery, direction) {
    if (!newPathQuery) {
        return false;
    }
    if (!oldPathQuery) {
        return true;
    }
    const newAmount = new bignumber_js_1.default(newPathQuery.amount);
    const oldAmount = oldPathQuery.amount;
    const better = (direction === types_1.SwapDirection.ExactIn) ? newAmount.gt(oldAmount) : newAmount.lt(oldAmount);
    return better;
}
function _doPathQuery(multicall, callings, callingPath, pathQueryPlugins, direction, amount, batchSize) {
    return __awaiter(this, void 0, void 0, function* () {
        let finalPathQueryResult = undefined;
        for (let i = 0; i < callings.length; i += batchSize) {
            const end = Math.min(i + batchSize, callings.length);
            const len = end - i;
            const batchCallings = callings.slice(i, end);
            const data = batchCallings.map((e) => e.calling);
            const contracts = batchCallings.map((e) => e.targetAddress);
            const { successes, results } = yield multiQuery(multicall, data, contracts);
            for (let j = 0; j < len; j++) {
                if (!successes[j] || results[j] === '0x') {
                    continue;
                }
                const idx = i + j;
                const path = callingPath[idx];
                let pathQueryResult = undefined;
                try {
                    pathQueryResult = pathQueryPlugins.parseCallingResponse(path, direction, amount, results[j]);
                }
                catch (_) { }
                if (!pathQueryResult) {
                    continue;
                }
                if (!pathQueryResult.noSufficientLiquidity) {
                    if (checkNewPathQueryBetter(finalPathQueryResult, pathQueryResult, direction)) {
                        finalPathQueryResult = Object.assign({}, pathQueryResult);
                        finalPathQueryResult.path = path;
                    }
                }
            }
        }
        return finalPathQueryResult;
    });
}
const doPathQuery = (params, preQueryResult) => __awaiter(void 0, void 0, void 0, function* () {
    var _b, _c;
    const { chainId, quoterAddress, web3, tokenIn, tokenOut, amount, direction, multicall } = params;
    const shortBatchSize = (_b = params.shortBatchSize) !== null && _b !== void 0 ? _b : 20;
    const longBatchSize = (_c = params.longBatchSize) !== null && _c !== void 0 ? _c : 20;
    const pathQueryPlugin = new SwapPathQueryPlugin_1.SwapPathQueryPlugin(preQueryResult, chainId, quoterAddress, web3);
    let finalPathQueryResult = undefined;
    const longCalling = [];
    const shortCalling = [];
    const longCallingPath = [];
    const shortCallingPath = [];
    const pathQueryList = pathQueryPlugin.getPathQuery(tokenIn, tokenOut, direction, amount);
    for (const pathQuery of pathQueryList) {
        if (pathQuery.path.tokenChain[0].symbol !== tokenIn.symbol) {
            continue;
        }
        if (pathQuery.path.tokenChain[pathQuery.path.tokenChain.length - 1].symbol !== tokenOut.symbol) {
            continue;
        }
        if (!pathQuery.pathQueryResult) {
            const pathQueryCalling = pathQuery.pathQueryCalling;
            if ((pathQueryCalling === null || pathQueryCalling === void 0 ? void 0 : pathQueryCalling.callingProperty) === types_1.CallingProperty.Short) {
                shortCalling.push(pathQueryCalling);
                shortCallingPath.push(pathQuery.path);
            }
            else if ((pathQueryCalling === null || pathQueryCalling === void 0 ? void 0 : pathQueryCalling.callingProperty) === types_1.CallingProperty.Long) {
                longCalling.push(pathQueryCalling);
                longCallingPath.push(pathQuery.path);
            }
        }
        else if (!pathQuery.pathQueryResult.noSufficientLiquidity) {
            if (checkNewPathQueryBetter(finalPathQueryResult, pathQuery.pathQueryResult, direction)) {
                finalPathQueryResult = Object.assign({}, pathQuery.pathQueryResult);
                finalPathQueryResult.path = pathQuery.path;
            }
        }
    }
    const shortPathQueryResult = yield _doPathQuery(multicall, shortCalling, shortCallingPath, pathQueryPlugin, direction, amount, shortBatchSize);
    const longPathQueryResult = yield _doPathQuery(multicall, longCalling, longCallingPath, pathQueryPlugin, direction, amount, longBatchSize);
    if (checkNewPathQueryBetter(finalPathQueryResult, shortPathQueryResult, direction)) {
        finalPathQueryResult = Object.assign({}, shortPathQueryResult);
        finalPathQueryResult.path = shortPathQueryResult.path;
    }
    if (checkNewPathQueryBetter(finalPathQueryResult, longPathQueryResult, direction)) {
        finalPathQueryResult = Object.assign({}, longPathQueryResult);
        finalPathQueryResult.path = longPathQueryResult.path;
    }
    return finalPathQueryResult;
});
exports.doPathQuery = doPathQuery;
