"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SwapPathQueryPlugin = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const base_1 = require("../base");
const types_1 = require("./types");
const quoter_1 = require("../quoter");
const SwapAmount = [
    {
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
    },
    {
        "internalType": "int24[]",
        "name": "pointAfterList",
        "type": "int24[]"
    }
];
class SwapPathQueryPlugin {
    constructor(preQueryResult, chainId, quoterAddress, web3) {
        this.direction = undefined;
        this.tokenIn = undefined;
        this.preQueryResult = preQueryResult;
        this.chainId = chainId;
        this.quoterContractAddress = quoterAddress;
        this.quoterContract = (0, quoter_1.getQuoterContract)(quoterAddress, web3);
        this.web3 = web3;
    }
    num2Hex(n) {
        if (n < 10) {
            return String(n);
        }
        const str = 'ABCDEF';
        return str[n - 10];
    }
    fee2Hex(fee) {
        const n0 = fee % 16;
        const n1 = Math.floor(fee / 16) % 16;
        const n2 = Math.floor(fee / 256) % 16;
        const n3 = Math.floor(fee / 4096) % 16;
        const n4 = 0;
        const n5 = 0;
        return '0x' + this.num2Hex(n5) + this.num2Hex(n4) + this.num2Hex(n3) + this.num2Hex(n2) + this.num2Hex(n1) + this.num2Hex(n0);
    }
    appendHex(hexString, newHexString) {
        return hexString + newHexString.slice(2);
    }
    getTokenChainPath(tokenChain, feeChain) {
        var _a, _b;
        let hexString = (_a = tokenChain[0].wrapTokenAddress) !== null && _a !== void 0 ? _a : tokenChain[0].address;
        for (let i = 0; i < feeChain.length; i++) {
            hexString = this.appendHex(hexString, this.fee2Hex(feeChain[i]));
            hexString = this.appendHex(hexString, (_b = tokenChain[i + 1].wrapTokenAddress) !== null && _b !== void 0 ? _b : tokenChain[i + 1].address);
        }
        return hexString;
    }
    getTokenChainPathReverse(tokenChain, feeChain) {
        var _a, _b;
        let hexString = (_a = tokenChain[tokenChain.length - 1].wrapTokenAddress) !== null && _a !== void 0 ? _a : tokenChain[tokenChain.length - 1].address;
        for (let i = feeChain.length - 1; i >= 0; i--) {
            hexString = this.appendHex(hexString, this.fee2Hex(feeChain[i]));
            hexString = this.appendHex(hexString, (_b = tokenChain[i].wrapTokenAddress) !== null && _b !== void 0 ? _b : tokenChain[i].address);
        }
        return hexString;
    }
    reverse(path) {
        return Object.assign(Object.assign({}, path), { tokenChain: path.tokenChain.slice().reverse(), feeContractNumber: path.feeContractNumber.slice().reverse() });
    }
    getPathQuery(tokenIn, tokenOut, direction, amount) {
        this.tokenIn = tokenIn;
        this.direction = direction;
        const preQueryResult = this.preQueryResult;
        const pathQuery = [];
        for (const path of preQueryResult.pathWithOutFee100) {
            const p = (path.tokenChain[0].symbol === tokenIn.symbol) ? path : this.reverse(path);
            const pathChain = (direction === types_1.SwapDirection.ExactIn) ? this.getTokenChainPath(p.tokenChain, p.feeContractNumber) : this.getTokenChainPathReverse(p.tokenChain, p.feeContractNumber);
            const calling = (direction === types_1.SwapDirection.ExactIn) ? this.quoterContract.methods.swapAmount(amount, pathChain) : this.quoterContract.methods.swapDesire(amount, pathChain);
            pathQuery.push({
                path: p,
                pathQueryCalling: {
                    calling: calling.encodeABI(),
                    targetAddress: this.quoterContractAddress,
                    callingProperty: types_1.CallingProperty.Short
                }
            });
        }
        for (const path of preQueryResult.pathWithFee100) {
            const p = (path.tokenChain[0].symbol === tokenIn.symbol) ? path : this.reverse(path);
            const pathChain = (direction === types_1.SwapDirection.ExactIn) ? this.getTokenChainPath(p.tokenChain, p.feeContractNumber) : this.getTokenChainPathReverse(p.tokenChain, p.feeContractNumber);
            const calling = (direction === types_1.SwapDirection.ExactIn) ? this.quoterContract.methods.swapAmount(amount, pathChain) : this.quoterContract.methods.swapDesire(amount, pathChain);
            pathQuery.push({
                path: p,
                pathQueryCalling: {
                    calling: calling.encodeABI(),
                    targetAddress: this.quoterContractAddress,
                    callingProperty: types_1.CallingProperty.Long
                }
            });
        }
        return pathQuery;
    }
    noSufficientLiquidity(path, pointAfterList) {
        for (let i = 0; i < path.feeContractNumber.length; i++) {
            const tokenA = path.tokenChain[i];
            const tokenB = path.tokenChain[i + 1];
            const tokenAAddress = (0, base_1.getSwapTokenAddress)(tokenA);
            const tokenBAddress = (0, base_1.getSwapTokenAddress)(tokenB);
            if (tokenAAddress.toLowerCase() < tokenBAddress.toLowerCase()) {
                // x2y mode
                if (pointAfterList[i] <= -799999) {
                    return true;
                }
            }
            else {
                // y2x mode
                if (pointAfterList[i] >= 799999) {
                    return true;
                }
            }
        }
        return false;
    }
    estimateFee(path, inputAmount) {
        let remainAmount = inputAmount;
        let remainRate = 1;
        for (const fee of path.feeContractNumber) {
            remainAmount = remainAmount - remainAmount * fee / 1e6;
            remainRate = remainRate * (1 - fee / 1e6);
        }
        return { feeAmount: inputAmount - remainAmount, feeRate: 1 - remainRate };
    }
    getSwapPoolKey(tokenA, tokenB, feeContractNumber) {
        const tokenASymbol = tokenA.symbol.toUpperCase();
        const tokenBSymbol = tokenB.symbol.toUpperCase();
        if (tokenASymbol < tokenBSymbol) {
            return tokenASymbol + '-' + tokenBSymbol + '-' + String(feeContractNumber);
        }
        else {
            return tokenBSymbol + '-' + tokenASymbol + '-' + String(feeContractNumber);
        }
    }
    getOriginPointList(path) {
        const ret = [];
        const preQueryResult = this.preQueryResult;
        for (let i = 0; i < path.feeContractNumber.length; i++) {
            const tokenA = path.tokenChain[i];
            const tokenB = path.tokenChain[i + 1];
            const fee = path.feeContractNumber[i];
            const swapPoolKey = this.getSwapPoolKey(tokenA, tokenB, fee);
            const point = preQueryResult.poolPoint.get(swapPoolKey);
            ret.push(point);
        }
        return ret;
    }
    getPriceDecimalEndByStart(path, pointList) {
        let decimalPriceEndByStart = 1;
        for (let i = 0; i < path.feeContractNumber.length; i++) {
            if (!pointList[i] && pointList[i] !== 0) {
                return undefined;
            }
            const decimalPriceBackByFront = (0, base_1.point2PriceDecimal)(path.tokenChain[i + 1], path.tokenChain[i], pointList[i]);
            decimalPriceEndByStart *= decimalPriceBackByFront;
        }
        return decimalPriceEndByStart;
    }
    parseCallingResponse(path, direction, amount, result) {
        let responseAmount = '0';
        let pointAfterList = [];
        if (direction === types_1.SwapDirection.ExactIn) {
            const swapAmountRes = this.web3.eth.abi.decodeParameters(SwapAmount, result);
            responseAmount = swapAmountRes["amount"];
            pointAfterList = swapAmountRes["pointAfterList"].map((e) => Number(e));
        }
        else {
            const swapDesireRes = this.web3.eth.abi.decodeParameters(SwapAmount, result);
            responseAmount = swapDesireRes["amount"];
            pointAfterList = swapDesireRes["pointAfterList"].slice().reverse().map((e) => Number(e));
        }
        const noSufficientLiquidity = this.noSufficientLiquidity(path, pointAfterList);
        const inputAmount = (this.direction === types_1.SwapDirection.ExactIn) ? amount : responseAmount;
        const inputAmountDecimal = Number((0, base_1.amount2Decimal)(new bignumber_js_1.default(inputAmount), this.tokenIn));
        const { feeAmount: feesDecimal, feeRate } = this.estimateFee(path, inputAmountDecimal);
        const pointBeforeList = this.getOriginPointList(path);
        const initDecimalPriceEndByStart = this.getPriceDecimalEndByStart(path, pointBeforeList);
        const afterDecimalPriceEndByStart = this.getPriceDecimalEndByStart(path, pointAfterList);
        const impact = Math.abs((afterDecimalPriceEndByStart - initDecimalPriceEndByStart) / initDecimalPriceEndByStart);
        const priceImpact = impact;
        return {
            amount: responseAmount,
            path,
            noSufficientLiquidity,
            initDecimalPriceEndByStart,
            priceImpact,
            feesDecimal,
            feeRate,
        };
    }
}
exports.SwapPathQueryPlugin = SwapPathQueryPlugin;
