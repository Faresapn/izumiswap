"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCollectLimitOrderCall = exports.getDecLimOrderCall = exports.getUpdateOrderCall = exports.getNewLimOrderCall = void 0;
const token_1 = require("../base/token");
const types_1 = require("../base/types");
const getNewLimOrderCall = (limitOrderManager, account, chain, params, gasPrice) => {
    var _a;
    const deadline = (_a = params.deadline) !== null && _a !== void 0 ? _a : '0xffffffff';
    let tokenXAddress = (0, token_1.getSwapTokenAddress)(params.sellToken).toLowerCase();
    let tokenYAddress = (0, token_1.getSwapTokenAddress)(params.earnToken).toLowerCase();
    let sellXEarnY = true;
    if (tokenXAddress > tokenYAddress) {
        sellXEarnY = false;
        let tmp = tokenYAddress;
        tokenYAddress = tokenXAddress;
        tokenXAddress = tmp;
    }
    const strictERC20Token = params.strictERC20Token;
    const options = {
        from: account,
        value: '0',
        maxFeePerGas: gasPrice,
    };
    if (strictERC20Token == undefined) {
        if ((0, token_1.isGasToken)(params.sellToken, chain.id)) {
            options.value = params.sellAmount;
        }
    }
    else if (!strictERC20Token) {
        if ((0, token_1.isGasOrWrappedGasToken)(params.sellToken, chain.id)) {
            options.value = params.sellAmount;
        }
    }
    const callings = [];
    const newLimOrderCalling = limitOrderManager.methods.newLimOrder(params.idx, {
        tokenX: tokenXAddress,
        tokenY: tokenYAddress,
        fee: params.fee,
        pt: params.point,
        amount: params.sellAmount,
        sellXEarnY,
        deadline
    });
    callings.push(newLimOrderCalling);
    if (options.value !== '0') {
        callings.push(limitOrderManager.methods.refundETH());
    }
    if (callings.length === 1) {
        return { newLimOrderCalling: callings[0], options: (0, types_1.buildSendingParams)(chain, options, gasPrice) };
    }
    const multicall = [];
    for (const c of callings) {
        multicall.push(c.encodeABI());
    }
    const newMulticall = limitOrderManager.methods.multicall(multicall);
    return { newLimOrderCalling: newMulticall, options: (0, types_1.buildSendingParams)(chain, options, gasPrice) };
};
exports.getNewLimOrderCall = getNewLimOrderCall;
const getUpdateOrderCall = (limitOrderManager, idx, account, chain, gasPrice) => {
    const options = {
        from: account,
        maxFeePerGas: gasPrice,
    };
    const updateOrderCalling = limitOrderManager.methods.updateOrder(idx);
    return {
        updateOrderCalling,
        options: (0, types_1.buildSendingParams)(chain, options, gasPrice)
    };
};
exports.getUpdateOrderCall = getUpdateOrderCall;
const getDecLimOrderCall = (limitOrderManager, orderIdx, decAmount, deadline, account, chain, gasPrice) => {
    const options = {
        from: account,
        maxFeePerGas: gasPrice,
    };
    const decLimOrderCalling = limitOrderManager.methods.decLimOrder(orderIdx, decAmount, deadline);
    return { decLimOrderCalling, options: (0, types_1.buildSendingParams)(chain, options, gasPrice) };
};
exports.getDecLimOrderCall = getDecLimOrderCall;
const getCollectLimitOrderCall = (limitOrderManager, account, chain, params, gasPrice) => {
    var _a;
    const strictERC20Token = params.strictERC20Token;
    const options = {
        from: account,
        maxFeePerGas: gasPrice,
    };
    let outputIsChainCoin = false;
    if (strictERC20Token == undefined) {
        outputIsChainCoin = (0, token_1.isGasToken)(params.tokenX, chain.id) || (0, token_1.isGasToken)(params.tokenY, chain.id);
    }
    else {
        outputIsChainCoin = (!strictERC20Token && ((0, token_1.isGasOrWrappedGasToken)(params.tokenX, chain.id) || (0, token_1.isGasOrWrappedGasToken)(params.tokenY, chain.id)));
    }
    const finalRecipientAddress = (_a = params.recipient) !== null && _a !== void 0 ? _a : account;
    const innerRecipientAddress = outputIsChainCoin ? '0x0000000000000000000000000000000000000000' : finalRecipientAddress;
    const callings = [];
    const collectCalling = limitOrderManager.methods.collectLimOrder(innerRecipientAddress, params.orderIdx, params.collectDecAmount, params.collectEarnAmount);
    callings.push(collectCalling);
    if (outputIsChainCoin) {
        callings.push(limitOrderManager.methods.unwrapWETH9('0', finalRecipientAddress));
        let sweepTokenAddress = (0, token_1.getSwapTokenAddress)(params.tokenX);
        if (chain.tokenSymbol === params.tokenX.symbol) {
            sweepTokenAddress = (0, token_1.getSwapTokenAddress)(params.tokenY);
        }
        callings.push(limitOrderManager.methods.sweepToken(sweepTokenAddress, '0', finalRecipientAddress));
    }
    if (callings.length === 1) {
        return { collectLimitOrderCalling: callings[0], options: (0, types_1.buildSendingParams)(chain, options, gasPrice) };
    }
    const multicall = [];
    for (const c of callings) {
        multicall.push(c.encodeABI());
    }
    return { collectLimitOrderCalling: limitOrderManager.methods.multicall(multicall), options: (0, types_1.buildSendingParams)(chain, options, gasPrice) };
};
exports.getCollectLimitOrderCall = getCollectLimitOrderCall;
