"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSwapChainWithExactOutputCall = exports.getSwapChainWithExactInputCall = exports.getSwapSingleWithExactOutputCall = exports.getSwapSingleWithExactInputCall = exports.getSwapContract = void 0;
const base_1 = require("../base");
const base_2 = require("../base");
const abi_json_1 = __importDefault(require("./abi.json"));
const getSwapContract = (address, web3) => {
    return (0, base_2.getEVMContract)(abi_json_1.default, address, web3);
};
exports.getSwapContract = getSwapContract;
const getSwapSingleWithExactInputCall = (swapContract, account, chain, params, gasPrice) => {
    var _a, _b, _c;
    const deadline = (_a = params.deadline) !== null && _a !== void 0 ? _a : '0xffffffff';
    const isX2Y = (0, base_1.getSwapTokenAddress)(params.inputToken).toLowerCase() < (0, base_1.getSwapTokenAddress)(params.outputToken).toLowerCase();
    const boundaryPt = (_b = params.boundaryPt) !== null && _b !== void 0 ? _b : (isX2Y ? -799999 : 799999);
    const strictERC20Token = params.strictERC20Token;
    const options = {
        from: account,
        value: '0',
        maxFeePerGas: gasPrice,
    };
    let inputIsChainCoin = false;
    let outputIsChainCoin = false;
    if (strictERC20Token == undefined) {
        inputIsChainCoin = (0, base_1.isGasToken)(params.inputToken, chain.id);
        outputIsChainCoin = (0, base_1.isGasToken)(params.outputToken, chain.id);
    }
    else {
        inputIsChainCoin = (!strictERC20Token && (0, base_1.isGasOrWrappedGasToken)(params.inputToken, chain.id));
        outputIsChainCoin = (!strictERC20Token && (0, base_1.isGasOrWrappedGasToken)(params.outputToken, chain.id));
    }
    if (inputIsChainCoin) {
        options.value = params.inputAmount;
    }
    const finalRecipientAddress = (_c = params.recipient) !== null && _c !== void 0 ? _c : account;
    const innerRecipientAddress = outputIsChainCoin ? '0x0000000000000000000000000000000000000000' : finalRecipientAddress;
    const callings = [];
    let swapCalling = undefined;
    if (isX2Y) {
        swapCalling = swapContract.methods.swapX2Y({
            tokenX: (0, base_1.getSwapTokenAddress)(params.inputToken),
            tokenY: (0, base_1.getSwapTokenAddress)(params.outputToken),
            fee: params.fee,
            boundaryPt,
            recipient: innerRecipientAddress,
            amount: params.inputAmount,
            maxPayed: '0',
            minAcquired: params.minOutputAmount,
            deadline
        });
    }
    else {
        swapCalling = swapContract.methods.swapY2X({
            tokenX: (0, base_1.getSwapTokenAddress)(params.outputToken),
            tokenY: (0, base_1.getSwapTokenAddress)(params.inputToken),
            fee: params.fee,
            boundaryPt,
            recipient: innerRecipientAddress,
            amount: params.inputAmount,
            maxPayed: '0',
            minAcquired: params.minOutputAmount,
            deadline
        });
    }
    callings.push(swapCalling);
    if (inputIsChainCoin) {
        callings.push(swapContract.methods.refundETH());
    }
    if (outputIsChainCoin) {
        callings.push(swapContract.methods.unwrapWETH9('0', finalRecipientAddress));
    }
    if (callings.length === 1) {
        return { swapCalling: callings[0], options: (0, base_2.buildSendingParams)(chain, options, gasPrice) };
    }
    const multicall = [];
    for (const c of callings) {
        multicall.push(c.encodeABI());
    }
    return { swapCalling: swapContract.methods.multicall(multicall), options: (0, base_2.buildSendingParams)(chain, options, gasPrice) };
};
exports.getSwapSingleWithExactInputCall = getSwapSingleWithExactInputCall;
const getSwapSingleWithExactOutputCall = (swapContract, account, chain, params, gasPrice) => {
    var _a, _b, _c;
    const deadline = (_a = params.deadline) !== null && _a !== void 0 ? _a : '0xffffffff';
    const isX2Y = (0, base_1.getSwapTokenAddress)(params.inputToken).toLowerCase() < (0, base_1.getSwapTokenAddress)(params.outputToken).toLowerCase();
    const boundaryPt = (_b = params.boundaryPt) !== null && _b !== void 0 ? _b : (isX2Y ? -799999 : 799999);
    const strictERC20Token = params.strictERC20Token;
    const options = {
        from: account,
        value: '0',
        maxFeePerGas: gasPrice,
    };
    let inputIsChainCoin = false;
    let outputIsChainCoin = false;
    if (strictERC20Token == undefined) {
        inputIsChainCoin = (0, base_1.isGasToken)(params.inputToken, chain.id);
        outputIsChainCoin = (0, base_1.isGasToken)(params.outputToken, chain.id);
    }
    else {
        inputIsChainCoin = (!strictERC20Token && (0, base_1.isGasOrWrappedGasToken)(params.inputToken, chain.id));
        outputIsChainCoin = (!strictERC20Token && (0, base_1.isGasOrWrappedGasToken)(params.outputToken, chain.id));
    }
    if (inputIsChainCoin) {
        options.value = params.maxInputAmount;
    }
    const finalRecipientAddress = (_c = params.recipient) !== null && _c !== void 0 ? _c : account;
    const innerRecipientAddress = outputIsChainCoin ? '0x0000000000000000000000000000000000000000' : finalRecipientAddress;
    const callings = [];
    let swapCalling = undefined;
    if (isX2Y) {
        swapCalling = swapContract.methods.swapX2YDesireY({
            tokenX: (0, base_1.getSwapTokenAddress)(params.inputToken),
            tokenY: (0, base_1.getSwapTokenAddress)(params.outputToken),
            fee: params.fee,
            boundaryPt,
            recipient: innerRecipientAddress,
            amount: params.outputAmount,
            maxPayed: params.maxInputAmount,
            minAcquired: params.outputAmount,
            deadline
        });
    }
    else {
        swapCalling = swapContract.methods.swapY2XDesireX({
            tokenX: (0, base_1.getSwapTokenAddress)(params.outputToken),
            tokenY: (0, base_1.getSwapTokenAddress)(params.inputToken),
            fee: params.fee,
            boundaryPt,
            recipient: innerRecipientAddress,
            amount: params.outputAmount,
            maxPayed: params.maxInputAmount,
            minAcquired: params.outputAmount,
            deadline
        });
    }
    callings.push(swapCalling);
    if (inputIsChainCoin) {
        callings.push(swapContract.methods.refundETH());
    }
    if (outputIsChainCoin) {
        callings.push(swapContract.methods.unwrapWETH9('0', finalRecipientAddress));
    }
    if (callings.length === 1) {
        return { swapCalling: callings[0], options: (0, base_2.buildSendingParams)(chain, options, gasPrice) };
    }
    const multicall = [];
    for (const c of callings) {
        multicall.push(c.encodeABI());
    }
    return { swapCalling: swapContract.methods.multicall(multicall), options: (0, base_2.buildSendingParams)(chain, options, gasPrice) };
};
exports.getSwapSingleWithExactOutputCall = getSwapSingleWithExactOutputCall;
const getSwapChainWithExactInputCall = (swapContract, account, chain, params, gasPrice) => {
    var _a, _b;
    const deadline = (_a = params.deadline) !== null && _a !== void 0 ? _a : '0xffffffff';
    const strictERC20Token = params.strictERC20Token;
    const options = {
        from: account,
        value: '0',
        maxFeePerGas: gasPrice,
    };
    const inputToken = params.tokenChain[0];
    const outputToken = params.tokenChain[params.tokenChain.length - 1];
    const path = (0, base_2.getTokenChainPath)(params.tokenChain, params.feeChain);
    let inputIsChainCoin = false;
    let outputIsChainCoin = false;
    if (strictERC20Token == undefined) {
        inputIsChainCoin = (0, base_1.isGasToken)(inputToken, chain.id);
        outputIsChainCoin = (0, base_1.isGasToken)(outputToken, chain.id);
    }
    else {
        inputIsChainCoin = (!strictERC20Token && (0, base_1.isGasOrWrappedGasToken)(inputToken, chain.id));
        outputIsChainCoin = (!strictERC20Token && (0, base_1.isGasOrWrappedGasToken)(outputToken, chain.id));
    }
    if (inputIsChainCoin) {
        options.value = params.inputAmount;
    }
    const finalRecipientAddress = (_b = params.recipient) !== null && _b !== void 0 ? _b : account;
    const innerRecipientAddress = outputIsChainCoin ? '0x0000000000000000000000000000000000000000' : finalRecipientAddress;
    const callings = [];
    const swapCalling = swapContract.methods.swapAmount({
        path,
        recipient: innerRecipientAddress,
        amount: params.inputAmount,
        minAcquired: params.minOutputAmount,
        deadline
    });
    callings.push(swapCalling);
    if (inputIsChainCoin) {
        callings.push(swapContract.methods.refundETH());
    }
    if (outputIsChainCoin) {
        callings.push(swapContract.methods.unwrapWETH9('0', finalRecipientAddress));
    }
    if (callings.length === 1) {
        return { swapCalling: callings[0], options: (0, base_2.buildSendingParams)(chain, options, gasPrice) };
    }
    const multicall = [];
    for (const c of callings) {
        multicall.push(c.encodeABI());
    }
    return { swapCalling: swapContract.methods.multicall(multicall), options: (0, base_2.buildSendingParams)(chain, options, gasPrice) };
};
exports.getSwapChainWithExactInputCall = getSwapChainWithExactInputCall;
const getSwapChainWithExactOutputCall = (swapContract, account, chain, params, gasPrice) => {
    var _a, _b;
    const deadline = (_a = params.deadline) !== null && _a !== void 0 ? _a : '0xffffffff';
    const strictERC20Token = params.strictERC20Token;
    const options = {
        from: account,
        value: '0',
        maxFeePerGas: gasPrice,
    };
    const inputToken = params.tokenChain[0];
    const outputToken = params.tokenChain[params.tokenChain.length - 1];
    const path = (0, base_2.getTokenChainPathReverse)(params.tokenChain, params.feeChain);
    let inputIsChainCoin = false;
    let outputIsChainCoin = false;
    if (strictERC20Token == undefined) {
        inputIsChainCoin = (0, base_1.isGasToken)(inputToken, chain.id);
        outputIsChainCoin = (0, base_1.isGasToken)(outputToken, chain.id);
    }
    else {
        inputIsChainCoin = (!strictERC20Token && (0, base_1.isGasOrWrappedGasToken)(inputToken, chain.id));
        outputIsChainCoin = (!strictERC20Token && (0, base_1.isGasOrWrappedGasToken)(outputToken, chain.id));
    }
    if (inputIsChainCoin) {
        options.value = params.maxInputAmount;
    }
    const finalRecipientAddress = (_b = params.recipient) !== null && _b !== void 0 ? _b : account;
    const innerRecipientAddress = outputIsChainCoin ? '0x0000000000000000000000000000000000000000' : finalRecipientAddress;
    const callings = [];
    const swapCalling = swapContract.methods.swapDesire({
        path,
        recipient: innerRecipientAddress,
        desire: params.outputAmount,
        maxPayed: params.maxInputAmount,
        deadline
    });
    callings.push(swapCalling);
    if (inputIsChainCoin) {
        callings.push(swapContract.methods.refundETH());
    }
    if (outputIsChainCoin) {
        callings.push(swapContract.methods.unwrapWETH9('0', finalRecipientAddress));
    }
    if (callings.length === 1) {
        return { swapCalling: callings[0], options: (0, base_2.buildSendingParams)(chain, options, gasPrice) };
    }
    const multicall = [];
    for (const c of callings) {
        multicall.push(c.encodeABI());
    }
    return { swapCalling: swapContract.methods.multicall(multicall), options: (0, base_2.buildSendingParams)(chain, options, gasPrice) };
};
exports.getSwapChainWithExactOutputCall = getSwapChainWithExactOutputCall;
