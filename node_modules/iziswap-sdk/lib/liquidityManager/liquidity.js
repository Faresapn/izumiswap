"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCollectLiquidityCall = exports.getDecLiquidityCall = exports.getAddLiquidityCall = exports.getMintCall = void 0;
const types_1 = require("../base/types");
const token_1 = require("../base/token");
const getMintCall = (liquidityManagerContract, account, chain, params, gasPrice) => {
    var _a, _b;
    const deadline = (_a = params.deadline) !== null && _a !== void 0 ? _a : '0xffffffff';
    const ifReverse = (0, token_1.getSwapTokenAddress)(params.tokenA).toLowerCase() > (0, token_1.getSwapTokenAddress)(params.tokenB).toLowerCase();
    const strictERC20Token = params.strictERC20Token;
    const options = {
        from: account,
        value: '0',
        maxFeePerGas: gasPrice,
    };
    if (strictERC20Token == undefined) {
        if ((0, token_1.isGasToken)(params.tokenA, chain.id)) {
            options.value = params.maxAmountA;
        }
        if ((0, token_1.isGasToken)(params.tokenB, chain.id)) {
            options.value = params.maxAmountB;
        }
    }
    else if (!strictERC20Token) {
        if ((0, token_1.isGasOrWrappedGasToken)(params.tokenA, chain.id)) {
            options.value = params.maxAmountA;
        }
        if ((0, token_1.isGasOrWrappedGasToken)(params.tokenB, chain.id)) {
            options.value = params.maxAmountB;
        }
    }
    const recipientAddress = (_b = params.recipient) !== null && _b !== void 0 ? _b : account;
    const callings = [];
    let mintCalling = undefined;
    if (ifReverse) {
        mintCalling = liquidityManagerContract.methods.mint({
            miner: recipientAddress,
            tokenX: (0, token_1.getSwapTokenAddress)(params.tokenB),
            tokenY: (0, token_1.getSwapTokenAddress)(params.tokenA),
            fee: params.fee,
            pl: params.leftPoint,
            pr: params.rightPoint,
            xLim: params.maxAmountB,
            yLim: params.maxAmountA,
            amountXMin: params.minAmountB,
            amountYMin: params.minAmountA,
            deadline
        });
    }
    else {
        mintCalling = liquidityManagerContract.methods.mint({
            miner: recipientAddress,
            tokenX: (0, token_1.getSwapTokenAddress)(params.tokenA),
            tokenY: (0, token_1.getSwapTokenAddress)(params.tokenB),
            fee: params.fee,
            pl: params.leftPoint,
            pr: params.rightPoint,
            xLim: params.maxAmountA,
            yLim: params.maxAmountB,
            amountXMin: params.minAmountA,
            amountYMin: params.minAmountB,
            deadline
        });
    }
    callings.push(mintCalling);
    if (options.value !== '0') {
        callings.push(liquidityManagerContract.methods.refundETH());
    }
    if (callings.length === 1) {
        return { mintCalling: callings[0], options: (0, types_1.buildSendingParams)(chain, options, gasPrice) };
    }
    const multicall = [];
    for (const c of callings) {
        multicall.push(c.encodeABI());
    }
    const mintMulticall = liquidityManagerContract.methods.multicall(multicall);
    return { mintCalling: mintMulticall, options: (0, types_1.buildSendingParams)(chain, options, gasPrice) };
};
exports.getMintCall = getMintCall;
const getAddLiquidityCall = (liquidityManagerContract, account, chain, params, gasPrice) => {
    var _a;
    const options = {
        from: account,
        value: '0',
        maxFeePerGas: gasPrice,
    };
    const strictERC20Token = params.strictERC20Token;
    if (strictERC20Token == undefined) {
        if ((0, token_1.isGasToken)(params.tokenA, chain.id)) {
            options.value = params.maxAmountA;
        }
        if ((0, token_1.isGasToken)(params.tokenB, chain.id)) {
            options.value = params.maxAmountB;
        }
    }
    else if (!strictERC20Token) {
        if ((0, token_1.isGasOrWrappedGasToken)(params.tokenA, chain.id)) {
            options.value = params.maxAmountA;
        }
        if ((0, token_1.isGasOrWrappedGasToken)(params.tokenB, chain.id)) {
            options.value = params.maxAmountB;
        }
    }
    const ifReverse = (0, token_1.getSwapTokenAddress)(params.tokenA).toLowerCase() > (0, token_1.getSwapTokenAddress)(params.tokenB).toLowerCase();
    const deadline = (_a = params.deadline) !== null && _a !== void 0 ? _a : '0xffffffff';
    const callings = [];
    let addLiquidityCalling = undefined;
    if (ifReverse) {
        addLiquidityCalling = liquidityManagerContract.methods.addLiquidity({
            lid: params.tokenId,
            xLim: params.maxAmountB,
            yLim: params.maxAmountA,
            amountXMin: params.minAmountB,
            amountYMin: params.minAmountA,
            deadline
        });
    }
    else {
        addLiquidityCalling = liquidityManagerContract.methods.addLiquidity({
            lid: params.tokenId,
            xLim: params.maxAmountA,
            yLim: params.maxAmountB,
            amountXMin: params.minAmountA,
            amountYMin: params.minAmountB,
            deadline
        });
    }
    callings.push(addLiquidityCalling);
    if (options.value !== '0') {
        callings.push(liquidityManagerContract.methods.refundETH());
    }
    if (callings.length === 1) {
        return { addLiquidityCalling: callings[0], options: (0, types_1.buildSendingParams)(chain, options, gasPrice) };
    }
    const multicall = [];
    for (const c of callings) {
        multicall.push(c.encodeABI());
    }
    const addMulticall = liquidityManagerContract.methods.multicall(multicall);
    return { addLiquidityCalling: addMulticall, options: (0, types_1.buildSendingParams)(chain, options, gasPrice) };
};
exports.getAddLiquidityCall = getAddLiquidityCall;
const getDecLiquidityCall = (liquidityManagerContract, account, chain, params, gasPrice) => {
    var _a;
    const options = {
        from: account,
        maxFeePerGas: gasPrice,
    };
    const deadline = (_a = params.deadline) !== null && _a !== void 0 ? _a : '0xffffffff';
    const decLiquidityCalling = liquidityManagerContract.methods.decLiquidity(params.tokenId, params.liquidDelta, params.minAmountX, params.minAmountY, deadline);
    return { decLiquidityCalling, options: (0, types_1.buildSendingParams)(chain, options, gasPrice) };
};
exports.getDecLiquidityCall = getDecLiquidityCall;
const getCollectLiquidityCall = (liquidityManagerContract, account, chain, params, gasPrice) => {
    var _a;
    const ifReverse = (0, token_1.getSwapTokenAddress)(params.tokenA).toLowerCase() > (0, token_1.getSwapTokenAddress)(params.tokenB).toLowerCase();
    const strictERC20Token = params.strictERC20Token;
    const options = {
        from: account,
        maxFeePerGas: gasPrice,
    };
    let outputIsChainCoin = false;
    if (strictERC20Token == undefined) {
        outputIsChainCoin = (0, token_1.isGasToken)(params.tokenA, chain.id) || (0, token_1.isGasToken)(params.tokenB, chain.id);
    }
    else {
        outputIsChainCoin = (!strictERC20Token && ((0, token_1.isGasOrWrappedGasToken)(params.tokenA, chain.id) || (0, token_1.isGasOrWrappedGasToken)(params.tokenB, chain.id)));
    }
    const finalRecipientAddress = (_a = params.recipient) !== null && _a !== void 0 ? _a : account;
    const innerRecipientAddress = outputIsChainCoin ? '0x0000000000000000000000000000000000000000' : finalRecipientAddress;
    const callings = [];
    let collectCalling = undefined;
    if (ifReverse) {
        collectCalling = liquidityManagerContract.methods.collect(innerRecipientAddress, params.tokenId, params.maxAmountB, params.maxAmountA);
    }
    else {
        collectCalling = liquidityManagerContract.methods.collect(innerRecipientAddress, params.tokenId, params.maxAmountA, params.maxAmountB);
    }
    callings.push(collectCalling);
    if (outputIsChainCoin) {
        callings.push(liquidityManagerContract.methods.unwrapWETH9('0', finalRecipientAddress));
        let sweepTokenAddress = (0, token_1.getSwapTokenAddress)(params.tokenA);
        if (chain.tokenSymbol === params.tokenA.symbol) {
            sweepTokenAddress = (0, token_1.getSwapTokenAddress)(params.tokenB);
        }
        callings.push(liquidityManagerContract.methods.sweepToken(sweepTokenAddress, '0', finalRecipientAddress));
    }
    if (callings.length === 1) {
        return { collectLiquidityCalling: callings[0], options: (0, types_1.buildSendingParams)(chain, options, gasPrice) };
    }
    const multicall = [];
    for (const c of callings) {
        multicall.push(c.encodeABI());
    }
    return { collectLiquidityCalling: liquidityManagerContract.methods.multicall(multicall), options: (0, types_1.buildSendingParams)(chain, options, gasPrice) };
};
exports.getCollectLiquidityCall = getCollectLiquidityCall;
