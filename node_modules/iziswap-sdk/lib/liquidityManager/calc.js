"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getWithdrawLiquidityValue = exports.getLiquidityValue = exports.calciZiLiquidityAmountDesired = void 0;
const bignumber_js_1 = require("bignumber.js");
const amountMath_1 = require("./library/amountMath");
const price_1 = require("../base/price");
const token_1 = require("../base/token/token");
const calciZiLiquidityAmountDesired = (leftPoint, rightPoint, currentPoint, amount, amountIsTokenA, tokenA, tokenB) => {
    if (amountIsTokenA) {
        if ((0, token_1.getSwapTokenAddress)(tokenA).toLowerCase() < (0, token_1.getSwapTokenAddress)(tokenB).toLowerCase()) {
            return (0, amountMath_1._calciZiLiquidityAmountY)(amount, leftPoint, rightPoint, currentPoint);
        }
        else {
            return (0, amountMath_1._calciZiLiquidityAmountX)(amount, leftPoint, rightPoint, currentPoint);
        }
    }
    else {
        if ((0, token_1.getSwapTokenAddress)(tokenA).toLowerCase() < (0, token_1.getSwapTokenAddress)(tokenB).toLowerCase()) {
            return (0, amountMath_1._calciZiLiquidityAmountX)(amount, leftPoint, rightPoint, currentPoint);
        }
        else {
            return (0, amountMath_1._calciZiLiquidityAmountY)(amount, leftPoint, rightPoint, currentPoint);
        }
    }
};
exports.calciZiLiquidityAmountDesired = calciZiLiquidityAmountDesired;
const getLiquidityValue = (liquidity, state) => {
    var _a, _b;
    let amountX = new bignumber_js_1.BigNumber(0);
    let amountY = new bignumber_js_1.BigNumber(0);
    const liquid = liquidity.liquidity;
    const sqrtRate = Math.sqrt(1.0001);
    const leftPtNum = Number(liquidity.leftPoint);
    const rightPtNum = Number(liquidity.rightPoint);
    // compute amountY without currentPt
    if (leftPtNum < state.currentPoint) {
        const rightPt = Math.min(state.currentPoint, rightPtNum);
        const sqrtPriceR = (0, price_1.point2PoolPriceUndecimalSqrt)(rightPt);
        const sqrtPriceL = (0, price_1.point2PoolPriceUndecimalSqrt)(leftPtNum);
        amountY = (0, amountMath_1._getAmountY)(new bignumber_js_1.BigNumber(liquid), sqrtPriceL, sqrtPriceR, sqrtRate, false);
    }
    // compute amountX without currentPt
    if (rightPtNum > state.currentPoint + 1) {
        const leftPt = Math.max(state.currentPoint + 1, leftPtNum);
        const sqrtPriceR = (0, price_1.point2PoolPriceUndecimalSqrt)(rightPtNum);
        amountX = (0, amountMath_1._getAmountX)(new bignumber_js_1.BigNumber(liquid), leftPt, rightPtNum, sqrtPriceR, sqrtRate, false);
    }
    // compute amountX and amountY on currentPt
    if (leftPtNum <= state.currentPoint && rightPtNum > state.currentPoint) {
        const liquidityValue = new bignumber_js_1.BigNumber(liquidity.liquidity);
        const maxLiquidityYAtCurrentPt = new bignumber_js_1.BigNumber(state.liquidity).minus(state.liquidityX);
        const liquidityYAtCurrentPt = liquidityValue.gt(maxLiquidityYAtCurrentPt) ? maxLiquidityYAtCurrentPt : liquidityValue;
        const liquidityXAtCurrentPt = liquidityValue.minus(liquidityYAtCurrentPt);
        const currentSqrtPrice = (0, price_1.point2PoolPriceUndecimalSqrt)(state.currentPoint);
        amountX = amountX.plus((0, amountMath_1._liquidity2AmountXAtPoint)(liquidityXAtCurrentPt, currentSqrtPrice, false));
        amountY = amountY.plus((0, amountMath_1._liquidity2AmountYAtPoint)(liquidityYAtCurrentPt, currentSqrtPrice, false));
    }
    const amountXDecimal = (_a = (0, token_1.amount2Decimal)(amountX, liquidity.tokenX)) !== null && _a !== void 0 ? _a : 0;
    const amountYDecimal = (_b = (0, token_1.amount2Decimal)(amountY, liquidity.tokenY)) !== null && _b !== void 0 ? _b : 0;
    return {
        amountX, amountXDecimal,
        amountY, amountYDecimal
    };
};
exports.getLiquidityValue = getLiquidityValue;
const getWithdrawLiquidityValue = (liquidity, state, withdrawLiquidity) => {
    var _a, _b;
    let amountX = new bignumber_js_1.BigNumber(0);
    let amountY = new bignumber_js_1.BigNumber(0);
    const sqrtRate = Math.sqrt(1.0001);
    const leftPtNum = Number(liquidity.leftPoint);
    const rightPtNum = Number(liquidity.rightPoint);
    // compute amountY without currentPt
    if (leftPtNum < state.currentPoint) {
        const rightPt = Math.min(state.currentPoint, rightPtNum);
        const sqrtPriceR = (0, price_1.point2PoolPriceUndecimalSqrt)(rightPt);
        const sqrtPriceL = (0, price_1.point2PoolPriceUndecimalSqrt)(leftPtNum);
        amountY = (0, amountMath_1._getAmountY)(withdrawLiquidity, sqrtPriceL, sqrtPriceR, sqrtRate, false);
    }
    // compute amountX without currentPt
    if (rightPtNum > state.currentPoint + 1) {
        const leftPt = Math.max(state.currentPoint + 1, leftPtNum);
        const sqrtPriceR = (0, price_1.point2PoolPriceUndecimalSqrt)(rightPtNum);
        amountX = (0, amountMath_1._getAmountX)(withdrawLiquidity, leftPt, rightPtNum, sqrtPriceR, sqrtRate, false);
    }
    // compute amountX and amountY on currentPt
    if (leftPtNum <= state.currentPoint && rightPtNum > state.currentPoint) {
        const liquidityValue = withdrawLiquidity;
        const maxLiquidityYAtCurrentPt = new bignumber_js_1.BigNumber(state.liquidity).minus(state.liquidityX);
        const liquidityYAtCurrentPt = liquidityValue.gt(maxLiquidityYAtCurrentPt) ? maxLiquidityYAtCurrentPt : liquidityValue;
        const liquidityXAtCurrentPt = liquidityValue.minus(liquidityYAtCurrentPt);
        const currentSqrtPrice = (0, price_1.point2PoolPriceUndecimalSqrt)(state.currentPoint);
        amountX = amountX.plus((0, amountMath_1._liquidity2AmountXAtPoint)(liquidityXAtCurrentPt, currentSqrtPrice, false));
        amountY = amountY.plus((0, amountMath_1._liquidity2AmountYAtPoint)(liquidityYAtCurrentPt, currentSqrtPrice, false));
    }
    const amountXDecimal = (_a = (0, token_1.amount2Decimal)(amountX, liquidity.tokenX)) !== null && _a !== void 0 ? _a : 0;
    const amountYDecimal = (_b = (0, token_1.amount2Decimal)(amountY, liquidity.tokenY)) !== null && _b !== void 0 ? _b : 0;
    return {
        amountX, amountXDecimal,
        amountY, amountYDecimal
    };
};
exports.getWithdrawLiquidityValue = getWithdrawLiquidityValue;
